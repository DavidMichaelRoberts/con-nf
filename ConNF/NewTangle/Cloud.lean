import Mathlib.Data.Set.Pairwise.Lattice
import ConNF.Mathlib.Logic
import ConNF.Fuzz
import ConNF.NewTangle.Code

/-!
# The `cloud` map

The `cloud` map from `γ` to `β ≠ γ` sends a set of `γ`-tangles to a set of `β`-tangles.
Each `γ`-tangle in the domain is sent to a "cloud" of `β`-typed near-litters, representing "junk"
at level `β`. This map will used to identify codes that represent the same TTT object.

An important property for intuition is that the `cloud` maps have disjoint ranges (except on empty
codes) and are each injective, so if we connect each code to its images under the `cloud` maps,
we get a tree (except for empty codes, which form a complete graph).

## Main declarations

* `ConNF.cloud`: The `cloud` map from `γ`-tangles to `β`-tangles, assuming `γ ≠ β`.
* `ConNF.extension`: The `cloud` map if `γ ≠ β`, otherwise the identity map.
* `ConNF.cloudCode`: The `cloud` map as a map from codes with any extension to codes of
    extension `β`.
* `ConNF.CloudRel`: The relation on codes generated by `cloudCode`. It relates `c` to `d` iff `d`
  is an image of `c` under the `cloudCode` map. This relation is well-founded on **nonempty** codes.
  See `ConNF.cloudRel'_wellFounded`.

## Notation

* `c ↝₀ d`: `d` is the image of `c` under the `cloudCode` map.
-/

open Function Set WithBot

open scoped Cardinal symmDiff

universe u

namespace ConNF

variable [Params.{u}] [Level] [BasePositions]

open Code

section Cloud

variable [ModelDataLt] [PositionedTanglesLt] [TypedObjectsLt] [PositionedObjectsLt]
  {γ : TypeIndex} [LtLevel γ] {β : Λ} [LtLevel β]
  (hγβ : γ ≠ β)

/-- The cloud map. We map each tangle to all typed near-litters near the `fuzz`ed tangle, and take
the union over all tangles in the input. -/
def cloud (s : Set (TSet γ)) : Set (TSet β) :=
  {u | ∃ t : Tangle γ, t.set_lt ∈ s ∧
    ∃ N : NearLitter, N.1 = fuzz hγβ t ∧ u = typedNearLitter N}

variable {hγβ}

@[simp]
theorem cloud_empty : cloud hγβ (∅ : Set (TSet γ)) = ∅ := by
  simp only [cloud, mem_empty_iff_false, false_and, exists_false, setOf_false]

@[simp]
theorem cloud_singleton (t : TSet γ) :
    cloud hγβ {t} = {u | ∃ t' : Tangle γ, t'.set_lt = t ∧
      ∃ N : NearLitter,  N.1 = fuzz hγβ t' ∧ u = typedNearLitter N} := by
  simp only [cloud, mem_singleton_iff, exists_eq_left]

variable {s : Set (TSet γ)} {t : TSet γ}

theorem _root_.Set.Nonempty.cloud (h : s.Nonempty) : (cloud hγβ s).Nonempty := by
  obtain ⟨u, hu⟩ := h
  obtain ⟨u, rfl⟩ := exists_tangle_lt u
  exact ⟨_, u, hu, (fuzz hγβ u).toNearLitter, rfl, rfl⟩

@[simp]
theorem cloud_eq_empty (hγβ : γ ≠ β) : cloud hγβ s = ∅ ↔ s = ∅ := by
  refine' ⟨fun h => not_nonempty_iff_eq_empty.1 fun hs => hs.cloud.ne_empty h, _⟩
  rintro rfl
  exact cloud_empty

@[simp]
theorem cloud_nonempty (hγβ : γ ≠ β) : (cloud hγβ s).Nonempty ↔ s.Nonempty := by
  simp_rw [nonempty_iff_ne_empty, Ne.def, cloud_eq_empty]

theorem subset_cloud (t : Tangle γ) (ht : t.set_lt ∈ s) :
    typedNearLitter '' {N | N.1 = fuzz hγβ t} ⊆ cloud hγβ s := by
  rintro _ ⟨N, hN, rfl⟩
  exact ⟨t, ht, N, hN, rfl⟩

theorem μ_le_mk_cloud : s.Nonempty → #μ ≤ #(cloud hγβ s) := by
  rintro ⟨t, ht⟩
  obtain ⟨t, rfl⟩ := exists_tangle_lt t
  refine' (Cardinal.mk_le_mk_of_subset <| subset_cloud t ht).trans_eq' _
  rw [Cardinal.mk_image_eq, mk_nearLitter_to]
  exact typedNearLitter.inj'

theorem subset_of_cloud_subset (s₁ s₂ : Set (TSet γ)) (h : cloud hγβ s₁ ⊆ cloud hγβ s₂) :
    s₁ ⊆ s₂ := by
  contrapose h
  rw [not_subset] at h ⊢
  obtain ⟨t, h₁, h₂⟩ := h
  obtain ⟨t, rfl⟩ := exists_tangle_lt t
  refine ⟨typedNearLitter (fuzz hγβ t).toNearLitter, ?_, ?_⟩
  · refine ⟨t, h₁, _, by exact rfl, rfl⟩
  · contrapose! h₂
    obtain ⟨u, hu, N, hN₁, hN₂⟩ := h₂
    cases typedNearLitter.injective hN₂
    cases fuzz_injective hγβ hN₁
    exact hu

theorem cloud_injective : Injective (cloud hγβ) := by
  intro s₁ s₂ h
  refine subset_antisymm ?_ ?_
  exact subset_of_cloud_subset s₁ s₂ (subset_of_eq h)
  exact subset_of_cloud_subset s₂ s₁ (subset_of_eq h.symm)

variable {δ : TypeIndex} [LtLevel δ]

theorem cloud_disjoint_range {hδβ} (c : Set (TSet γ)) (d : Set (TSet δ)) (hc : c.Nonempty)
    (h : cloud hγβ c = cloud hδβ d) : γ = δ := by
  obtain ⟨b, hb⟩ := hc
  obtain ⟨b, rfl⟩ := exists_tangle_lt b
  have := (Set.ext_iff.mp h (typedNearLitter (fuzz hγβ b).toNearLitter)).mp
    ⟨b, hb, _, by exact rfl, rfl⟩
  obtain ⟨b', _, N, hN₁, hN₂⟩ := this
  cases typedNearLitter.injective hN₂
  exact fuzz_congr_β hN₁

/-!
We don't need to prove that the ranges of the `cloud` maps are disjoint for different `β`, since
this holds at the type level.

We now show that there are only finitely many iterated images under any inverse `cloud` map, in the
case of nonempty sets.
-/

theorem wellFounded_pos : WellFounded fun a b : Tangle γ => pos a < pos b :=
  InvImage.wf _ IsWellFounded.wf

/-- The minimum tangle of a nonempty set of tangles. -/
noncomputable def minTangle (s : Set (Tangle γ)) (hs : s.Nonempty) : Tangle γ :=
  wellFounded_pos.min s hs

theorem minTangle_mem (s : Set (Tangle γ)) (hs : s.Nonempty) : minTangle s hs ∈ s :=
  WellFounded.min_mem _ s hs

theorem minTangle_le (s : Set (Tangle γ)) (hs : s.Nonempty) {t : Tangle γ} (ht : t ∈ s) :
    pos (minTangle s hs) ≤ pos t :=
  not_lt.1 <| wellFounded_pos.not_lt_min s hs ht

theorem set_invImage_nonempty (s : Set (TSet γ)) (hs : s.Nonempty) :
    (Tangle.set_lt ⁻¹' s).Nonempty := by
  obtain ⟨t, ht⟩ := hs
  obtain ⟨t, rfl⟩ := exists_tangle_lt t
  exact ⟨t, ht⟩

noncomputable def minTSet (s : Set (TSet γ)) (hs : s.Nonempty) : Tangle γ :=
  minTangle (Tangle.set_lt ⁻¹' s) (set_invImage_nonempty s hs)

theorem minTSet_lt_minTSet_cloud (s : Set (TSet γ)) (hs : s.Nonempty) :
    pos (minTSet s hs) < pos (minTSet (cloud hγβ s) hs.cloud) := by
  obtain ⟨t, ht, N, hN, h⟩ := minTangle_mem (Tangle.set_lt ⁻¹' cloud hγβ s)
    (set_invImage_nonempty _ hs.cloud)
  have := pos_typedNearLitter N
    (minTangle (Tangle.set_lt ⁻¹' cloud hγβ s) (set_invImage_nonempty _ hs.cloud)) h
  refine lt_of_le_of_lt (minTangle_le _ _ ht) ?_
  exact (pos_lt_pos_fuzz_nearLitter hγβ t _ hN).trans_le this

end Cloud

section CloudCode

variable [ModelDataLt] [PositionedTanglesLt]

/-- Tool that lets us use well-founded recursion on codes via `μ`.
This maps a nonempty code to the least pos of a tangle in the extension of the code. -/
noncomputable def codeMinMap (c : NonemptyCode) : μ :=
  pos <| minTSet _ c.prop

/-- The pullback `<` relation on codes is well-founded. -/
theorem invImage_codeMinMap_wf : WellFounded (InvImage (· < ·) (codeMinMap : NonemptyCode → μ)) :=
  InvImage.wf codeMinMap IsWellFounded.wf

section Extension

variable [TypedObjectsLt] {β : TypeIndex} [LtLevel β]

/-- The `cloud` map, phrased as a function on sets of `γ`-tangles, but if `γ = β`, this is the
identity function. -/
def extension (s : Set (TSet β)) (γ : Λ) [LtLevel γ] : Set (TSet γ) :=
  if hβγ : β = γ then cast (by subst hβγ; rfl) s else cloud hβγ s

@[simp]
theorem extension_self {γ : Λ} [LtLevel γ] (s : Set (TSet γ)) : extension s γ = s :=
  dif_pos rfl

variable (s : Set (TSet β)) (γ : Λ) [LtLevel γ]

@[simp]
theorem extension_eq (hβγ : β = γ) : extension s γ = cast (by subst hβγ; rfl) s :=
  dif_pos hβγ

@[simp]
theorem extension_ne (hβγ : β ≠ γ) : extension s γ = cloud hβγ s :=
  dif_neg hβγ

end Extension

variable [TypedObjectsLt] [PositionedObjectsLt]
  (γ : TypeIndex) [LtLevel γ] (β : Λ) [LtLevel β] (c d : Code)

/-- The `cloud` map, phrased as a function on `α`-codes, but if the code's level matches `β`,
this is the identity function. This is written in a weird way in order to make `(cloudCode β c).1`
defeq to `β`. -/
def cloudCode (c : Code) : Code :=
  mk β (extension c.members β)

theorem cloudCode_eq (hcβ : c.1 = β) : cloudCode β c = c := by
  rw [cloudCode, extension_eq _ _ hcβ]
  ext : 1
  · exact hcβ.symm
  · simp only [cast_heq]

theorem cloudCode_ne (hcβ : c.1 ≠ β) : cloudCode β c = mk β (cloud hcβ c.members) := by
  rw [cloudCode, extension_ne _ _ hcβ]

@[simp]
theorem fst_cloudCode : (cloudCode β c).1 = β :=
  rfl

@[simp]
theorem snd_cloudCode (hcβ : c.1 ≠ β) : (cloudCode β c).members = cloud hcβ c.members := by
  have := cloudCode_ne β c hcβ
  rw [Code.ext_iff] at this
  exact this.2.eq

@[simp]
theorem cloudCode_mk_eq (s) : cloudCode β (mk β s) = mk β s := by
  rw [cloudCode_eq]
  rfl

@[simp]
theorem cloudCode_mk_ne (hγβ : γ ≠ β) (s) : cloudCode β (mk γ s) = mk β (cloud hγβ s) :=
  by rw [cloudCode_ne β (mk γ s) hγβ]

variable {β c d}

@[simp]
theorem cloudCode_isEmpty : (cloudCode β c).IsEmpty ↔ c.IsEmpty := by
  obtain ⟨γ, s⟩ := c
  by_cases h : γ = β
  · rw [cloudCode_eq]
    exact h
  · rw [cloudCode_ne]
    exact cloud_eq_empty h

@[simp]
theorem cloudCode_nonempty : (cloudCode β c).members.Nonempty ↔ c.members.Nonempty := by
  simp_rw [nonempty_iff_ne_empty]; exact cloudCode_isEmpty.not

alias ⟨_, Code.IsEmpty.cloudCode⟩ := cloudCode_isEmpty

theorem cloudCode_injOn : {c : Code | c.1 ≠ β ∧ c.members.Nonempty}.InjOn (cloudCode β) := by
  rintro ⟨γ, s⟩ ⟨hγβ, hs⟩ ⟨δ, t⟩ ⟨hδβ, ht⟩ h
  rw [cloudCode_ne _ _ hγβ, cloudCode_ne _ _ hδβ] at h
  have := (congr_arg_heq Code.members h).eq
  obtain rfl := cloud_disjoint_range _ _ hs this
  dsimp only at this
  rw [cloud_injective this]

theorem μ_le_mk_cloudCode (c : Code) (hcβ : c.1 ≠ β) :
    c.members.Nonempty → #μ ≤ #(cloudCode β c).members := by
  rw [cloudCode_ne β c hcβ]
  exact μ_le_mk_cloud (hγβ := hcβ)

variable (β)

theorem codeMinMap_lt_codeMinMap_cloudCode (c : NonemptyCode) (hcβ : c.1.1 ≠ β) :
    codeMinMap c < codeMinMap ⟨cloudCode β c, cloudCode_nonempty.mpr c.2⟩ := by
  unfold codeMinMap
  have := cloudCode_ne β c hcβ
  convert minTSet_lt_minTSet_cloud c.1.members c.2 using 1
  congr
  exact snd_cloudCode β c hcβ

/-- This relation on `α`-codes allows us to state that there are only finitely many iterated images
under the inverse `cloud` map. Note that we require the map to actually change the data, by
stipulating that `c.1 ≠ β`. -/
@[mk_iff]
inductive CloudRel (c : Code) : Code → Prop
  | intro (β : Λ) [LtLevel β] : c.1 ≠ β → CloudRel c (cloudCode β c)

infixl:62 " ↝₀ " => CloudRel

theorem cloudRel_subsingleton (hc : c.members.Nonempty) : {d : Code | d ↝₀ c}.Subsingleton := by
  intro d hd e he
  simp only [cloudRel_iff] at hd he
  obtain ⟨β, hβ, hdβ, rfl⟩ := hd
  obtain ⟨γ, hγ, heγ, h⟩ := he
  have := ((Code.ext_iff _ _).1 h).1
  simp only [fst_cloudCode, coe_inj] at this
  subst this
  refine' cloudCode_injOn ⟨hdβ, cloudCode_nonempty.1 hc⟩ _ h
  rw [h] at hc
  exact ⟨heγ, cloudCode_nonempty.1 hc⟩

theorem cloudRel_cloudCode (hd : d.members.Nonempty) (hdβ : d.1 ≠ β) :
    c ↝₀ cloudCode β d ↔ c = d := by
  refine'
    ⟨fun h => cloudRel_subsingleton (by rwa [cloudCode_nonempty]) h <| CloudRel.intro _ hdβ, _⟩
  rintro rfl
  exact ⟨_, hdβ⟩

theorem CloudRel.nonempty_iff : c ↝₀ d → (c.members.Nonempty ↔ d.members.Nonempty) := by
  rintro ⟨β, hcβ⟩
  exact cloudCode_nonempty.symm

theorem cloudRelEmptyEmpty (hγβ : γ ≠ β) : mk γ ∅ ↝₀ mk β ∅ :=
  (cloudRel_iff _ _).2
    ⟨β, inferInstance, hγβ, by
      ext : 1
      · rfl
      · refine heq_of_eq ?_
        simp only [snd_cloudCode _ (mk γ ∅) hγβ, cloud_empty]⟩

theorem eq_of_cloudCode {β γ : Λ} [LtLevel β] [LtLevel γ]
    (hc : c.members.Nonempty) (hcβ : c.1 ≠ β) (hdγ : d.1 ≠ γ)
    (h : cloudCode β c = cloudCode γ d) : c = d := by
  refine cloudRel_subsingleton (by rwa [cloudCode_nonempty]) (CloudRel.intro _ hcβ) ?_
  rw [h]
  exact CloudRel.intro _ hdγ

/-- This relation on `α`-codes allows us to state that there are only finitely many iterated images
under the inverse `cloud` map. -/
@[mk_iff]
inductive CloudRel' (c : NonemptyCode) : NonemptyCode → Prop
  | intro (β : Λ) [LtLevel β] :
      (c : Code).1 ≠ β → CloudRel' c ⟨cloudCode β c, cloudCode_nonempty.mpr c.2⟩

infixl:62 " ↝ " => CloudRel'

@[simp]
theorem cloudRel_coe_coe {c d : NonemptyCode} : (c : Code) ↝₀ d ↔ c ↝ d := by
  rw [cloudRel_iff, cloudRel'_iff]
  aesop

theorem cloud_subrelation : Subrelation (· ↝ ·) (InvImage (· < ·) (codeMinMap : NonemptyCode → μ))
  | c, _, CloudRel'.intro β hc => codeMinMap_lt_codeMinMap_cloudCode β c hc

/-- There are only finitely many iterated images under any inverse `cloud` map. -/
theorem cloudRel'_wellFounded : WellFounded ((· ↝ ·) : _ → NonemptyCode → Prop) :=
  cloud_subrelation.wf invImage_codeMinMap_wf

instance : WellFoundedRelation NonemptyCode :=
  ⟨_, cloudRel'_wellFounded⟩

/-- There is at most one inverse under an `cloud` map. This corresponds to the fact that there is
only one code which is related (on the left) to any given code under the `cloud` map relation. -/
theorem cloudRel'_subsingleton (c : NonemptyCode) :
    {d : NonemptyCode | d ↝ c}.Subsingleton := by
  intro d hd e he
  simp only [Ne.def, cloudRel'_iff, mem_setOf_eq] at hd he
  obtain ⟨β, hβ, hdβ, rfl⟩ := hd
  obtain ⟨γ, hγ, heγ, h⟩ := he
  rw [Subtype.ext_iff] at h
  have := ((Code.ext_iff _ _).1 h).1
  simp only [Subtype.coe_mk, fst_cloudCode, coe_eq_coe] at this
  subst this
  exact Subtype.coe_injective (cloudCode_injOn ⟨hdβ, d.2⟩ ⟨heγ, e.2⟩ h)

end CloudCode

end ConNF
