import ConNF.Mathlib.Logic
import ConNF.Fuzz
import ConNF.NewTangle.Code

/-!
# The `cloud` map

The `cloud` map from `γ` to `β ≠ γ` sends a set of `γ`-tangles to a set of `β`-tangles.
Each `γ`-tangle in the domain is sent to a "cloud" of `β`-typed near-litters, representing "junk"
at level `β`. This map will used to identify codes that represent the same TTT object.

An important property for intuition is that the `cloud` maps have disjoint ranges (except on empty
codes) and are each injective, so if we connect each code to its images under the `cloud` maps,
we get a tree (except for empty codes, which form a complete graph).

## Main declarations

* `ConNF.cloud`: The `cloud` map from `γ`-tangles to `β`-tangles, assuming `γ ≠ β`.
* `ConNF.extension`: The `cloud` map if `γ ≠ β`, otherwise the identity map.
* `ConNF.cloudCode`: The `cloud` map as a map from codes with any extension to codes of
    extension `β`.
* `ConNF.CloudRel`: The relation on codes generated by `cloudCode`. It relates `c` to `d` iff `d`
  is an image of `c` under the `cloudCode` map. This relation is well-founded on **nonempty** codes.
  See `ConNF.cloudRel'_wellFounded`.

## Notation

* `c ↝₀ d`: `d` is the image of `c` under the `cloudCode` map.
-/

open Function Set WithBot

open scoped Cardinal

universe u

namespace ConNF

variable [Params.{u}] [BasePositions]

open Code

section Cloud

variable {α : Λ} {γ : IioBot α} [TangleData γ] [PositionedTangles γ] {β : Iio α}
  [TangleData (iioCoe β)] [PositionedTangles (iioCoe β)] [TypedObjects β] (hγβ : γ ≠ β)

theorem coe_ne : γ ≠ β → (γ : TypeIndex) ≠ (β : Λ) :=
  Subtype.coe_injective.ne

/-- The cloud map. We map each tangle to all typed near-litters near the `fuzz`ed tangle, and take
the union over all tangles in the input. -/
def cloud (s : Set (Tangle γ)) : Set (Tangle <| iioCoe β) :=
  typedNearLitter '' ⋃ t ∈ s, localCardinal (fuzz (coe_ne hγβ) t)

variable {hγβ}

@[simp]
theorem mem_cloud {t : Tangle <| iioCoe β} {s : Set (Tangle γ)} :
    t ∈ cloud hγβ s ↔
      ∃ t' ∈ s, ∃ (N : NearLitter), N.1 = fuzz (coe_ne hγβ) t' ∧ t = typedNearLitter N := by
  simp only [cloud, mem_image, mem_iUnion, mem_localCardinal, exists_prop]
  constructor
  · rintro ⟨N, ⟨t, ht₁, ht₂⟩, rfl⟩
    exact ⟨t, ht₁, N, ht₂, rfl⟩
  · rintro ⟨t, ht₁, N, ht₂, rfl⟩
    exact ⟨N, ⟨t, ht₁, ht₂⟩, rfl⟩

@[simp]
theorem cloud_empty : cloud hγβ (∅ : Set (Tangle γ)) = ∅ := by
  simp only [cloud, mem_empty_iff_false, iUnion_of_empty, iUnion_empty, image_empty]

@[simp]
theorem cloud_singleton (t : Tangle γ) :
    cloud hγβ {t} = typedNearLitter '' localCardinal (fuzz (coe_ne hγβ) t) := by
  simp only [cloud, mem_singleton_iff, iUnion_iUnion_eq_left]

variable {s : Set (Tangle γ)} {t : Tangle γ}

theorem _root_.Set.Nonempty.cloud (h : s.Nonempty) : (cloud hγβ s).Nonempty := by
  refine (nonempty_iUnion.2 ?_).image _
  refine ⟨h.choose, ⟨(fuzz (coe_ne hγβ) h.choose).toNearLitter, ?_⟩⟩
  simp only [mem_iUnion, mem_localCardinal, Litter.toNearLitter_fst, exists_prop, and_true]
  exact h.choose_spec

@[simp]
theorem cloud_eq_empty (hγβ : γ ≠ β) : cloud hγβ s = ∅ ↔ s = ∅ := by
  refine' ⟨fun h => not_nonempty_iff_eq_empty.1 fun hs => hs.cloud.ne_empty h, _⟩
  rintro rfl
  exact cloud_empty

@[simp]
theorem cloud_nonempty (hγβ : γ ≠ β) : (cloud hγβ s).Nonempty ↔ s.Nonempty := by
  simp_rw [nonempty_iff_ne_empty, Ne.def, cloud_eq_empty]

theorem subset_cloud (ht : t ∈ s) :
    typedNearLitter '' localCardinal (fuzz (coe_ne hγβ) t) ⊆ cloud hγβ s :=
  image_subset _ <| subset_iUnion₂ (s := fun t' _ => localCardinal (fuzz (coe_ne hγβ) t')) t ht

theorem μ_le_mk_cloud : s.Nonempty → #μ ≤ #(cloud hγβ s) := by
  rintro ⟨t, ht⟩
  refine' (Cardinal.mk_le_mk_of_subset <| subset_cloud ht).trans_eq' _
  rw [Cardinal.mk_image_eq, mk_localCardinal]
  exact typedNearLitter.inj'

theorem cloud_injective : Injective (cloud hγβ) :=
  typedNearLitter.injective.image_injective.comp <|
    Pairwise.biUnion_injective (fun _ _ h => localCardinal_disjoint <| (fuzz_injective _).ne h)
      fun _ => localCardinal_nonempty _

variable {δ : IioBot α} [TangleData δ] [PositionedTangles δ]

theorem cloud_disjoint_range {hδβ} (c : Set (Tangle γ)) (d : Set (Tangle δ)) (hc : c.Nonempty)
    (h : cloud hγβ c = cloud hδβ d) : γ = δ := by
  obtain ⟨b, hb⟩ := hc
  have := (subset_iUnion₂ b hb).trans (typedNearLitter.injective.image_injective h).subset
  obtain ⟨i, -, hi⟩ := mem_iUnion₂.1 (this (fuzz _ b).toNearLitter_mem_localCardinal)
  refine Subtype.coe_injective ?_
  exact (fuzz_β (coe_ne hγβ) b).trans ((congr_arg Litter.β hi).trans (fuzz_β (coe_ne hδβ) i))

/-!
We don't need to prove that the ranges of the `cloud` maps are disjoint for different `β`, since
this holds at the type level.

We now show that there are only finitely many iterated images under any inverse `cloud` map, in the
case of nonempty sets.
-/

theorem wellFounded_pos : WellFounded fun a b : Tangle γ => pos a < pos b :=
  InvImage.wf _ IsWellFounded.wf

/-- The minimum tangle of a nonempty set of tangles. -/
noncomputable def minTangle (s : Set (Tangle γ)) (hs : s.Nonempty) : Tangle γ :=
  wellFounded_pos.min s hs

theorem minTangle_mem (s : Set (Tangle γ)) (hs : s.Nonempty) : minTangle s hs ∈ s :=
  WellFounded.min_mem _ s hs

theorem minTangle_le (s : Set (Tangle γ)) (hs : s.Nonempty) {t : Tangle γ} (ht : t ∈ s) :
    pos (minTangle s hs) ≤ pos t :=
  not_lt.1 <| wellFounded_pos.not_lt_min s hs ht

theorem minTangle_lt_minTangle_cloud (s : Set (Tangle γ)) (hs : s.Nonempty) :
    pos (minTangle s hs) < pos (minTangle (cloud hγβ s) hs.cloud) := by
  obtain ⟨t, ht, N, hN, h⟩ := mem_cloud.1 (minTangle_mem (cloud hγβ s) hs.cloud)
  refine (minTangle_le s hs ht).trans_lt ?_
  rw [h]
  exact fuzz_pos (coe_ne hγβ) t _ hN

end Cloud

section CloudCode

variable {α : Λ} [TangleDataIio α] [PositionedTanglesIio α]

/-- Tool that lets us use well-founded recursion on codes via `μ`.
This maps a nonempty code to the least pos of a tangle in the extension of the code. -/
noncomputable def codeMinMap (c : NonemptyCode α) : μ :=
  pos <| minTangle _ c.prop

/-- The pullback `<` relation on codes is well-founded. -/
theorem invImage_codeMinMap_wf : WellFounded (InvImage μr (codeMinMap : NonemptyCode α → μ)) :=
  InvImage.wf codeMinMap μwo.wf

section Extension

variable [TypedObjectsIio α] {β : IioBot α}

/-- The `cloud` map, phrased as a function on sets of `γ`-tangles, but if `γ = β`, this is the
identity function. -/
def extension (s : Set (Tangle β)) (γ : Iio α) : Set (Tangle γ) :=
  if hβγ : β = γ then cast (by rw [hβγ]) s else cloud hβγ s

@[simp]
theorem extension_self {γ : Iio α} (s : Set (Tangle (iioCoe γ))) : extension s γ = s :=
  dif_pos rfl

variable (s : Set (Tangle β)) (γ : Iio α)

@[simp]
theorem extension_eq (hβγ : β = γ) : extension s γ = cast (by rw [hβγ]) s :=
  dif_pos hβγ

@[simp]
theorem extension_ne (hβγ : β ≠ γ) : extension s γ = cloud hβγ s :=
  dif_neg hβγ

end Extension

variable [TypedObjectsIio α] (γ : IioBot α) (β : Iio α) (c d : Code α)

/-- The `cloud` map, phrased as a function on `α`-codes, but if the code's level matches `β`,
this is the identity function. This is written in a weird way in order to make `(cloudCode β c).1`
defeq to `β`. -/
def cloudCode (c : Code α) : Code α :=
  mk β (extension c.2 β)

theorem cloudCode_eq (hcβ : c.1 = β) : cloudCode β c = c := by
  rw [cloudCode, extension_eq _ _ hcβ]
  ext : 1
  · exact hcβ.symm
  · simp only [snd_mk, cast_heq]

theorem cloudCode_ne (hcβ : c.1 ≠ β) : cloudCode β c = mk β (cloud hcβ c.2) := by
  rw [cloudCode, extension_ne _ _ hcβ]

@[simp]
theorem fst_cloudCode : (cloudCode β c).1 = β :=
  rfl

@[simp]
theorem snd_cloudCode (hcβ : c.1 ≠ β) : (cloudCode β c).2 = cloud hcβ c.2 := by
  have := cloudCode_ne β c hcβ
  rw [Sigma.ext_iff] at this
  exact this.2.eq

@[simp]
theorem cloudCode_mk_eq (s) : cloudCode β (mk β s) = mk β s := by
  rw [cloudCode_eq]
  rfl

@[simp]
theorem cloudCode_mk_ne (hγβ : γ ≠ β) (s) : cloudCode β (mk γ s) = mk β (cloud hγβ s) := by
  rw [cloudCode_ne β (mk γ s) hγβ]
  rfl

variable {β c d}

@[simp]
theorem cloudCode_isEmpty : (cloudCode β c).IsEmpty ↔ c.IsEmpty := by
  obtain ⟨γ, s⟩ := c
  by_cases h : γ = β
  · rw [cloudCode_eq]
    exact h
  · rw [cloudCode_ne]
    exact cloud_eq_empty h
    exact h

@[simp]
theorem cloudCode_nonempty : (cloudCode β c).2.Nonempty ↔ c.2.Nonempty := by
  simp_rw [nonempty_iff_ne_empty]; exact cloudCode_isEmpty.not

alias ⟨_, Code.IsEmpty.cloudCode⟩ := cloudCode_isEmpty

theorem cloudCode_injOn : {c : Code α | c.1 ≠ β ∧ c.2.Nonempty}.InjOn (cloudCode β) := by
  rintro ⟨γ, s⟩ ⟨hγβ, hs⟩ ⟨δ, t⟩ ⟨hδβ, ht⟩ h
  rw [cloudCode_ne _ _ hγβ, cloudCode_ne _ _ hδβ] at h
  have := (congr_arg_heq Sigma.snd h).eq
  simp only [fst_mk, snd_mk] at this
  obtain rfl := cloud_disjoint_range _ _ hs this
  rw [cloud_injective this]

theorem μ_le_mk_cloudCode (c : Code α) (hcβ : c.1 ≠ β) :
    c.2.Nonempty → #μ ≤ #(cloudCode β c).2 := by
  rw [cloudCode_ne β c hcβ]
  exact μ_le_mk_cloud (hγβ := hcβ)

variable (β)

theorem codeMinMap_lt_codeMinMap_cloudCode (c : NonemptyCode α) (hcβ : c.1.1 ≠ β) :
    codeMinMap c < codeMinMap ⟨cloudCode β c, cloudCode_nonempty.mpr c.2⟩ := by
  unfold codeMinMap
  have := cloudCode_ne β c hcβ
  convert minTangle_lt_minTangle_cloud c.1.2 c.2 using 1
  congr
  exact snd_cloudCode β c hcβ

/-- This relation on `α`-codes allows us to state that there are only finitely many iterated images
under the inverse `cloud` map. Note that we require the map to actually change the data, by
stipulating that `c.1 ≠ β`. -/
@[mk_iff]
inductive CloudRel (c : Code α) : Code α → Prop
  | intro (β : Iio α) : c.1 ≠ β → CloudRel c (cloudCode β c)

infixl:62 " ↝₀ " => CloudRel

theorem cloudRel_subsingleton (hc : c.2.Nonempty) : {d : Code α | d ↝₀ c}.Subsingleton := by
  intro d hd e he
  simp only [CloudRel_iff] at hd he
  obtain ⟨⟨β, hβ⟩, hdβ, rfl⟩ := hd
  obtain ⟨⟨γ, hγ⟩, heγ, h⟩ := he
  have := congr_arg Subtype.val (Sigma.ext_iff.1 h).1
  dsimp only [fst_cloudCode, Iio.coe_mk] at this
  rw [coe_eq_coe] at this
  subst this
  refine' cloudCode_injOn ⟨hdβ, cloudCode_nonempty.1 hc⟩ _ h
  rw [h] at hc
  exact ⟨heγ, cloudCode_nonempty.1 hc⟩

theorem cloudRel_cloudCode (hd : d.2.Nonempty) (hdβ : d.1 ≠ β) : c ↝₀ cloudCode β d ↔ c = d := by
  refine'
    ⟨fun h => cloudRel_subsingleton (by rwa [cloudCode_nonempty]) h <| CloudRel.intro _ hdβ, _⟩
  rintro rfl
  exact ⟨_, hdβ⟩

theorem CloudRel.nonempty_iff : c ↝₀ d → (c.2.Nonempty ↔ d.2.Nonempty) := by
  rintro ⟨β, hcβ⟩
  exact cloudCode_nonempty.symm

theorem cloudRelEmptyEmpty (hγβ : γ ≠ β) : mk γ ∅ ↝₀ mk β ∅ :=
  (CloudRel_iff _ _).2
    ⟨β, hγβ, by
      ext : 1
      · rfl
      · refine heq_of_eq ?_
        simp only [snd_mk, snd_cloudCode _ (mk γ ∅) hγβ, cloud_empty]⟩

theorem eq_of_cloudCode {β γ : Iio α} (hc : c.2.Nonempty) (hcβ : c.1 ≠ β) (hdγ : d.1 ≠ γ)
    (h : cloudCode β c = cloudCode γ d) : c = d := by
  refine cloudRel_subsingleton (by rwa [cloudCode_nonempty]) (CloudRel.intro _ hcβ) ?_
  rw [h]
  exact CloudRel.intro _ hdγ

/-- This relation on `α`-codes allows us to state that there are only finitely many iterated images
under the inverse `cloud` map. -/
@[mk_iff]
inductive CloudRel' (c : NonemptyCode α) : NonemptyCode α → Prop
  | intro (β : Iio α) : (c : Code α).1 ≠ β → CloudRel' c ⟨cloudCode β c, cloudCode_nonempty.mpr c.2⟩

infixl:62 " ↝ " => CloudRel'

@[simp]
theorem cloudRel_coe_coe {c d : NonemptyCode α} : (c : Code α) ↝₀ d ↔ c ↝ d := by
  rw [CloudRel_iff, CloudRel'_iff, Iff.comm]
  exact exists_congr fun β => and_congr_right' Subtype.ext_iff

theorem cloud_subrelation : Subrelation (· ↝ ·) (InvImage μr (codeMinMap : NonemptyCode α → μ))
  | c, _, CloudRel'.intro β hc => codeMinMap_lt_codeMinMap_cloudCode β c hc

/-- There are only finitely many iterated images under any inverse `cloud` map. -/
theorem cloudRel'_wellFounded : WellFounded ((· ↝ ·) : _ → NonemptyCode α → Prop) :=
  cloud_subrelation.wf invImage_codeMinMap_wf

instance : WellFoundedRelation (NonemptyCode α) :=
  ⟨_, cloudRel'_wellFounded⟩

/-- There is at most one inverse under an `cloud` map. This corresponds to the fact that there is
only one code which is related (on the left) to any given code under the `cloud` map relation. -/
theorem cloudRel'_subsingleton (c : NonemptyCode α) :
    {d : NonemptyCode α | d ↝ c}.Subsingleton := by
  intro d hd e he
  simp only [Ne.def, CloudRel'_iff, mem_setOf_eq] at hd he
  obtain ⟨⟨β, hβ⟩, hdβ, rfl⟩ := hd
  obtain ⟨⟨γ, hγ⟩, heγ, h⟩ := he
  rw [Subtype.ext_iff] at h
  have := congr_arg Subtype.val (Sigma.ext_iff.1 h).1
  simp only [Subtype.coe_mk, fst_cloudCode, Iio.coe_mk, coe_eq_coe] at this
  subst this
  exact Subtype.coe_injective (cloudCode_injOn ⟨hdβ, d.2⟩ ⟨heγ, e.2⟩ h)

end CloudCode

end ConNF
