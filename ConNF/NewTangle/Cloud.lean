import ConNF.Mathlib.Logic
import ConNF.Fuzz
import ConNF.NewTangle.Code

/-!
# Alternative extensions

The alternative extension map, aka A-map, from `γ` to `β` sends a code of extension `γ` to its
lternative extension `β`. This will used to identify codes and construct the TTT objects.

An important property for intuition is that A-maps have disjoint ranges (except on empty codes) and
are each injective, so if we connect each code to its images under A-maps, we get a tree (except for
empty codes that form a complete graph).

## Main declarations

* `con_nf.cloud`: Alternative extension map as a map from sets of `γ`-tangles to of `β`-tangles.
  Note that `γ` can be any type index while `β` has to be a proper type index.
* `con_nf.cloudCode`: Alternative extension map as a map from codes to codes of extension `β`.
* `con_nf.cloud_rel`: The relation on codes generated by `cloudCode`. It relates `c` to `d` iff `d`
  is the image of `c` under some A-map. This relation is well-founded on **nonempty** codes. See
  `con_nf.cloud_rel'_well_founded`.

## Notation

* `c ↝ d`: `d` is the image of `c` under some A-map.
-/

open Function Set WithBot

open scoped Cardinal

universe u

namespace ConNF

variable [Params.{u}] [BasePositions]

open Code

section Cloud

variable {α : Λ} {γ : IioBot α} [TangleData γ] [PositionFunction γ] {β : Iio α}
  [TangleData (iioCoe β)] [PositionFunction (iioCoe β)] [TypedObjects β] (hγβ : γ ≠ β)

theorem coe_ne : γ ≠ β → (γ : TypeIndex) ≠ (β : Λ) :=
  Subtype.coe_injective.ne

/-- The *alternative extension* map. For a set of tangles `G`, consider the code
`(α, γ, G)`. We then construct the non-empty set `D` such that `(α, β, D)` is an alternative
extension of the same object in TTT. -/
def cloud (s : Set (Tangle γ)) : Set (Tangle <| iioCoe β) :=
  typedNearLitter '' ⋃ t ∈ s, localCardinal (fuzz (coe_ne hγβ) t)

variable {hγβ}

@[simp]
theorem mem_cloud {t : Tangle <| iioCoe β} {s : Set (Tangle γ)} :
    t ∈ cloud hγβ s ↔
      ∃ t' ∈ s, ∃ (N : NearLitter), N.1 = fuzz (coe_ne hγβ) t' ∧ t = typedNearLitter N := by
  simp only [cloud, mem_image, mem_iUnion, mem_localCardinal, exists_prop]
  constructor
  · rintro ⟨N, ⟨t, ht₁, ht₂⟩, rfl⟩
    exact ⟨t, ht₁, N, ht₂, rfl⟩
  · rintro ⟨t, ht₁, N, ht₂, rfl⟩
    exact ⟨N, ⟨t, ht₁, ht₂⟩, rfl⟩

@[simp]
theorem cloud_empty : cloud hγβ (∅ : Set (Tangle γ)) = ∅ := by
  simp only [cloud, mem_empty_iff_false, iUnion_of_empty, iUnion_empty, image_empty]

@[simp]
theorem cloud_singleton (t) :
    cloud hγβ ({t} : Set (Tangle γ)) = typedNearLitter '' localCardinal (fuzz (coe_ne hγβ) t) := by
  simp only [cloud, mem_singleton_iff, iUnion_iUnion_eq_left]

variable {s : Set (Tangle γ)} {t : Tangle γ}

theorem _root_.Set.Nonempty.cloud (h : s.Nonempty) : (cloud hγβ s).Nonempty := by
  refine (nonempty_iUnion.2 ?_).image _
  refine ⟨h.choose, ⟨(fuzz (coe_ne hγβ) h.choose).toNearLitter, ?_⟩⟩
  simp only [mem_iUnion, mem_localCardinal, Litter.toNearLitter_fst, exists_prop, and_true]
  exact h.choose_spec

@[simp]
theorem cloud_eq_empty (hγβ : γ ≠ β) : cloud hγβ s = ∅ ↔ s = ∅ := by
  refine' ⟨fun h => not_nonempty_iff_eq_empty.1 fun hs => hs.cloud.ne_empty h, _⟩
  rintro rfl
  exact cloud_empty

@[simp]
theorem cloud_nonempty (hγβ : γ ≠ β) : (cloud hγβ s).Nonempty ↔ s.Nonempty := by
  simp_rw [nonempty_iff_ne_empty, Ne.def, cloud_eq_empty]

theorem subset_cloud (ht : t ∈ s) :
    typedNearLitter '' localCardinal (fuzz (coe_ne hγβ) t) ⊆ cloud hγβ s :=
  image_subset _ <| subset_iUnion₂ (s := fun t' _ => localCardinal (fuzz (coe_ne hγβ) t')) t ht

theorem μ_le_mk_cloud : s.Nonempty → #μ ≤ #(cloud hγβ s) := by
  rintro ⟨t, ht⟩
  refine' (Cardinal.mk_le_mk_of_subset <| subset_cloud ht).trans_eq' _
  rw [Cardinal.mk_image_eq, mk_localCardinal]
  exact typedNearLitter.inj'

theorem cloud_injective : Injective (cloud hγβ) :=
  typedNearLitter.injective.image_injective.comp <|
    Pairwise.biUnion_injective (fun _ _ h => localCardinal_disjoint <| (fuzz_injective _).ne h)
      fun _ => localCardinal_nonempty _

variable {δ : IioBot α} [TangleData δ] [PositionFunction δ]
  {hδβ : (δ : TypeIndex) ≠ (β : Λ)}

theorem cloud_disjoint_range {hδβ} (c : Set (Tangle γ)) (d : Set (Tangle δ)) (hc : c.Nonempty)
    (h : cloud hγβ c = cloud hδβ d) : γ = δ := by
  obtain ⟨b, hb⟩ := hc
  have := (subset_iUnion₂ b hb).trans (typedNearLitter.injective.image_injective h).subset
  obtain ⟨i, -, hi⟩ := mem_iUnion₂.1 (this (fuzz _ b).toNearLitter_mem_localCardinal)
  refine Subtype.coe_injective ?_
  exact (fuzz_β (coe_ne hγβ) b).trans ((congr_arg Litter.β hi).trans (fuzz_β (coe_ne hδβ) i))

/-!
We don't need to prove that the ranges of the `A_δ` are disjoint for different `β`, since this holds
at the type level.

We now show that there are only finitely many iterated images under any inverse A-map, in the case
of nonempty sets.
-/

theorem wellFounded_position : WellFounded fun a b : Tangle γ => position a < position b :=
  InvImage.wf _ IsWellFounded.wf

/-- The minimum tangle of a nonempty set of tangles. -/
noncomputable def minTangle (c : Set (Tangle γ)) (hc : c.Nonempty) : Tangle γ :=
  wellFounded_position.min c hc

theorem minTangle_mem (c : Set (Tangle γ)) (hc : c.Nonempty) : minTangle c hc ∈ c :=
  WellFounded.min_mem _ c hc

theorem minTangle_le (c : Set (Tangle γ)) (hc : c.Nonempty) {x} (hx : x ∈ c) :
    position (minTangle c hc) ≤ position x :=
  not_lt.1 <| wellFounded_position.not_lt_min c hc hx

theorem cloud_order (c : Set (Tangle γ)) (hc : c.Nonempty) :
    position (minTangle c hc) < position (minTangle (cloud hγβ c) hc.cloud) := by
  obtain ⟨t, ht, s, hs, h⟩ := mem_cloud.1 (minTangle_mem (cloud hγβ c) hc.cloud)
  refine (minTangle_le c hc ht).trans_lt ?_
  rw [h]
  exact fuzz_position (coe_ne hγβ) t _ hs

end Cloud

section CloudCode

variable {α : Λ} [TangleDataIio α] [PositionFunctionIio α]

/-- Tool that lets us use well-founded recursion on codes via `μ`. -/
noncomputable def codeMinMap (c : NonemptyCode α) : μ :=
  position <| minTangle _ c.prop

/-- The pullback `<` relation on codes is well-founded. -/
theorem code_wf : WellFounded (InvImage μr (codeMinMap : NonemptyCode α → μ)) :=
  InvImage.wf codeMinMap μwo.wf

section Extension

variable [TypedObjectsIio α] {β : IioBot α}

/-- The A-map, phrased as a function on sets of `γ`-tangles, but if `γ = β`, this is the
identity function. This is the true alternative extension map. -/
def extension (s : Set (Tangle β)) (γ : Iio α) : Set (Tangle γ) :=
  if hβγ : β = γ then cast (by rw [hβγ]) s else cloud hβγ s

@[simp]
theorem extension_self {γ : Iio α} (s : Set (Tangle (iioCoe γ))) : extension s γ = s :=
  dif_pos rfl

variable (s : Set (Tangle β)) (γ : Iio α)

@[simp]
theorem extension_eq (hβγ : β = γ) : extension s γ = cast (by rw [hβγ]) s :=
  dif_pos hβγ

@[simp]
theorem extension_ne (hβγ : β ≠ γ) : extension s γ = cloud hβγ s :=
  dif_neg hβγ

end Extension

variable [TypedObjectsIio α] (γ : IioBot α) (β : Iio α) (c d : Code α)

/-- The A-map, phrased as a function on `α`-codes, but if the code's level matches `β`, this is the
identity function. This is written in a weird way in order to make `(cloudCode β c).1` defeq
to `β`. -/
def cloudCode (c : Code α) : Code α :=
  mk β (extension c.2 β)

theorem cloudCode_eq (hcβ : c.1 = β) : cloudCode β c = c :=
  by
  rw [cloudCode, extension_eq _ _ hcβ]
  ext : 1
  · exact hcβ.symm
  · simp only [snd_mk, cast_heq]

theorem cloudCode_ne (hcβ : c.1 ≠ β) : cloudCode β c = mk β (cloud hcβ c.2) := by
  rw [cloudCode, extension_ne _ _ hcβ]

@[simp]
theorem fst_cloudCode : (cloudCode β c).1 = β :=
  rfl

@[simp]
theorem snd_cloudCode (hcβ : c.1 ≠ β) : (cloudCode β c).2 = cloud hcβ c.2 := by
  have := cloudCode_ne β c hcβ
  rw [Sigma.ext_iff] at this
  exact this.2.eq

@[simp]
theorem cloudCode_mk_eq (s) : cloudCode β (mk β s) = mk β s := by rw [cloudCode_eq]; rfl

@[simp]
theorem cloudCode_mk_ne (hγβ : γ ≠ β) (s) : cloudCode β (mk γ s) = mk β (cloud hγβ s) := by
  rw [cloudCode_ne β (mk γ s) hγβ]; rfl

variable {β c d}

@[simp]
theorem cloudCode_isEmpty : (cloudCode β c).IsEmpty ↔ c.IsEmpty :=
  by
  obtain ⟨γ, s⟩ := c
  by_cases γ = β
  · rw [cloudCode_eq]
    exact h
  · rw [cloudCode_ne]
    exact cloud_eq_empty h
    exact h

@[simp]
theorem cloudCode_nonempty : (cloudCode β c).2.Nonempty ↔ c.2.Nonempty := by
  simp_rw [nonempty_iff_ne_empty]; exact cloudCode_isEmpty.not

alias ⟨_, Code.IsEmpty.cloudCode⟩ := cloudCode_isEmpty

theorem cloudCode_injOn : {c : Code α | c.1 ≠ β ∧ c.2.Nonempty}.InjOn (cloudCode β) := by
  rintro ⟨γ, s⟩ ⟨hγβ, hs⟩ ⟨δ, t⟩ ⟨hδβ, ht⟩ h
  rw [cloudCode_ne _ _ hγβ, cloudCode_ne _ _ hδβ] at h
  have := (congr_arg_heq Sigma.snd h).eq
  simp only [fst_mk, snd_mk] at this
  obtain rfl := cloud_disjoint_range _ _ hs this
  rw [cloud_injective this]

theorem μ_le_mk_cloudCode (c : Code α) (hcβ : c.1 ≠ β) : c.2.Nonempty → #μ ≤ #(cloudCode β c).2 := by
  rw [cloudCode_ne β c hcβ]
  exact μ_le_mk_cloud (hγβ := hcβ)

variable (β)

theorem cloudCode_order (c : NonemptyCode α) (hcβ : c.1.1 ≠ β) :
    codeMinMap c < codeMinMap ⟨cloudCode β c, cloudCode_nonempty.mpr c.2⟩ := by
  unfold codeMinMap
  have := cloudCode_ne β c hcβ
  convert cloud_order c.1.2 c.2 using 1
  congr
  exact snd_cloudCode β c hcβ

/-- This relation on `α`-codes allows us to state that there are only finitely many iterated images
under the inverse A-map. Note that we require the A-map to actually change the data, by requiring
that `c.1 ≠ β`. -/
@[mk_iff]
inductive CloudRel (c : Code α) : Code α → Prop
  | intro (β : Iio α) : c.1 ≠ β → CloudRel c (cloudCode β c)

infixl:62 " ↝ " => CloudRel

theorem cloudRel_subsingleton (hc : c.2.Nonempty) : {d : Code α | d ↝ c}.Subsingleton := by
  intro d hd e he
  simp only [CloudRel_iff] at hd he
  obtain ⟨⟨β, hβ⟩, hdβ, rfl⟩ := hd
  obtain ⟨⟨γ, hγ⟩, heγ, h⟩ := he
  have := congr_arg Subtype.val (Sigma.ext_iff.1 h).1
  dsimp only [fst_cloudCode, Iio.coe_mk] at this
  rw [coe_eq_coe] at this
  subst this
  refine' cloudCode_injOn ⟨hdβ, cloudCode_nonempty.1 hc⟩ _ h
  rw [h] at hc
  exact ⟨heγ, cloudCode_nonempty.1 hc⟩

theorem cloudRel_cloudCode (hd : d.2.Nonempty) (hdβ : d.1 ≠ β) : c ↝ cloudCode β d ↔ c = d := by
  refine'
    ⟨fun h => cloudRel_subsingleton (by rwa [cloudCode_nonempty]) h <| CloudRel.intro _ hdβ, _⟩
  rintro rfl
  exact ⟨_, hdβ⟩

theorem CloudRel.nonempty_iff : c ↝ d → (c.2.Nonempty ↔ d.2.Nonempty) := by
  rintro ⟨β, hcβ⟩
  exact cloudCode_nonempty.symm

theorem cloudRelEmptyEmpty (hγβ : γ ≠ β) : mk γ ∅ ↝ mk β ∅ :=
  (CloudRel_iff _ _).2
    ⟨β, hγβ, by
      ext : 1
      · rfl
      · refine heq_of_eq ?_
        simp only [snd_mk, snd_cloudCode _ (mk γ ∅) hγβ, cloud_empty]⟩

theorem eq_of_cloudCode {β γ : Iio α} (hc : c.2.Nonempty) (hcβ : c.1 ≠ β) (hdγ : d.1 ≠ γ)
    (h : cloudCode β c = cloudCode γ d) : c = d := by
  refine cloudRel_subsingleton (by rwa [cloudCode_nonempty]) (CloudRel.intro _ hcβ) ?_
  rw [h]
  exact CloudRel.intro _ hdγ

/-- This relation on `α`-codes allows us to state that there are only finitely many iterated images
under the inverse A-map. -/
@[mk_iff]
inductive CloudRel' (c : NonemptyCode α) : NonemptyCode α → Prop
  | intro (β : Iio α) : (c : Code α).1 ≠ β → CloudRel' c ⟨cloudCode β c, cloudCode_nonempty.mpr c.2⟩

@[simp]
theorem cloudRel_coe_coe {c d : NonemptyCode α} : (c : Code α) ↝ d ↔ CloudRel' c d := by
  rw [CloudRel_iff, CloudRel'_iff, Iff.comm]
  exact exists_congr fun β => and_congr_right' Subtype.ext_iff

theorem cloud_subrelation : Subrelation CloudRel' (InvImage μr (codeMinMap : NonemptyCode α → μ))
  | c, _, CloudRel'.intro β hc => cloudCode_order β c hc

/-- There are only finitely many iterated images under any inverse A-map. -/
theorem cloudRel'_wellFounded : WellFounded (CloudRel' : _ → NonemptyCode α → Prop) :=
  cloud_subrelation.wf code_wf

instance : WellFoundedRelation (NonemptyCode α) :=
  ⟨_, cloudRel'_wellFounded⟩

/-- There is at most one inverse under an A-map. This corresponds to the fact that there is only one
code which is related (on the left) to any given code under the A-map relation. -/
theorem cloudRel'_subsingleton (c : NonemptyCode α) :
    {d : NonemptyCode α | CloudRel' d c}.Subsingleton :=
  by
  intro d hd e he
  simp only [Ne.def, CloudRel'_iff, mem_setOf_eq] at hd he
  obtain ⟨⟨β, hβ⟩, hdβ, rfl⟩ := hd
  obtain ⟨⟨γ, hγ⟩, heγ, h⟩ := he
  rw [Subtype.ext_iff] at h
  have := congr_arg Subtype.val (Sigma.ext_iff.1 h).1
  simp only [Subtype.coe_mk, fst_cloudCode, Iio.coe_mk, coe_eq_coe] at this
  subst this
  exact Subtype.coe_injective (cloudCode_injOn ⟨hdβ, d.2⟩ ⟨heγ, e.2⟩ h)

end CloudCode

end ConNF
