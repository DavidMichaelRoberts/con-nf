\documentclass{article}

\usepackage{util}

\title{Con(NF)}
\author{Sky Wilshaw}

\begin{document}

\maketitle

\section{Setup}

\subsection{Model parameters}

\begin{definition}
    If \( \alpha \) is a type, \( \# \alpha \) is the cardinal representing the size of \( \alpha \).
    If \( \kappa \) is a cardinal, \( \mathsf{ord}(\kappa) \) is the ordinal given by \( \kappa \).
    Both of these operations are applied implicitly where required.
\end{definition}
\begin{param}
    Let \( \lambda \) be the type of \emph{proper type indices} with a well-ordering \( <_\lambda \).
    Assume that the order type of \( <_\lambda \) is \( \mathsf{ord}(\#\lambda) \), and \( \#\lambda \) is a limit cardinal.
    Let \( \kappa \) be a type where \( \#\kappa \) is an uncountable regular cardinal strictly larger than \( \#\lambda \).
    Let \( \mu \) be a type with a well-ordering \( <_\mu \).
    Assume that the order type of \( <_\mu \) is \( \mathsf{ord}(\#\mu) \).
    Assume that \( \#\mu \) is a strong limit cardinal creater than \( \#\kappa \), and \( \#\mu \) has cofinality at least \( \#\kappa \).
\end{param}
\begin{remark}
    These parameters can be satisfied with \( \lambda = \mathbb N \), \( \#\kappa = \aleph_1 \), \( \#\mu = \beth_{\omega_1} \).
\end{remark}
\begin{definition}
    A \emph{type index} is an element of \( \lambda \), or the symbol \( \bot \), representing a base type (also called `type \( -1 \)') below all types.
    The type of type indices is denoted \( \lambda^\bot \).
\end{definition}
\begin{lemma}
    Type indices are well-ordered with \( \bot \le \alpha \) for all \( \alpha : \lambda^\bot \), and \( \#\lambda^\bot = \#\lambda \).
\end{lemma}
\begin{definition}
    A \emph{litter} is a structure with
    \begin{itemize}
        \item an \emph{index} \( \nu : \mu \);
        \item a \emph{source type index} \( \beta : \lambda^\bot \);
        \item a \emph{target proper type index} \( \gamma : \lambda \);
        \item such that \( \beta \neq \gamma \).
    \end{itemize}
\end{definition}
\begin{lemma}
    There are \( \#\mu \) litters.
\end{lemma}
\begin{definition}
    An \emph{atom} is a litter together with an index in \( \kappa \).
\end{definition}
\begin{lemma}
    There are \( \#\mu \) atoms.
\end{lemma}
\begin{definition}
    A type or a set is \emph{small} if its cardinality is strictly smaller than \( \#\kappa \).
    Two sets are \emph{near} if their symmetric difference is small.
\end{definition}

\subsection{Pretangles}

\begin{definition}
    Let \( \alpha : \lambda^\bot \) be a type index.
    An \emph{\( \alpha \)-pretangle} is
    \begin{itemize}
        \item if \( \alpha = \bot \), an atom;
        \item otherwise, for each \( \beta : \lambda^\bot \) such that \( \beta < \alpha \), a set of \( \beta \)-pretangles.
    \end{itemize}
    We define \( \tau_\alpha^\star \) to be the type of \( \alpha \)-pretangles.
\end{definition}
\begin{definition}
    Let \( \beta < \alpha \) be type indices.
    Then there is a membership relation betweeen \( \tau_\beta^\star \) and \( \tau_\alpha^\star \).
\end{definition}

\subsection{Type indices}

\begin{definition}
    Let \( \alpha : \lambda \).
    We define the type \( \lambda_\alpha \) of proper type indices strictly below \( \alpha \), and \( \lambda_\alpha^\bot \) of type indices strictly below \( \alpha \).
\end{definition}
\begin{definition}
    A quiver structure is defined on \( \lambda^\bot \) by defining \( \alpha \longrightarrow \beta \) if \( \beta < \alpha \).
    An \emph{\( \alpha \)-extended index} is a path in this quiver from \( \alpha \) to \( \bot \).
    If \( A \) is a path from \( \alpha \) to \( \beta \) and \( B \) is a path from \( \beta \) to \( \gamma \), we denote their \emph{composition} by \( A \gg B \), a path from \( \alpha \) to \( \gamma \).
\end{definition}
\begin{remark}
    Paths are implemented like `snoc-lists'; extracting the last segment of a path is easy, and extracting the first is more difficult.
\end{remark}
\begin{lemma}
    There are at most \( \#\lambda \) \( \alpha \)-extended indices.
\end{lemma}

\subsection{Litters}

\begin{definition}
    The \emph{litter set} corresponding to a litter \( L \) is the set of atoms \( a = (L', i) \) where \( L = L' \).
    We transparently cast litters to litter sets as necessary (but not in reverse).
\end{definition}
\begin{lemma}
    The litter sets are pairwise disjoint and have cardinality \( \#\kappa \).
\end{lemma}
\begin{definition}
    A set \( N \) \emph{is a near-litter} to a litter \( L \) if it has small symmetric difference from the litter set of \( L \).
    A \emph{near-litter} is a litter \( L \) together with a set \( N \) that is a near-litter to \( L \).
\end{definition}
\begin{remark}
    We keep track of the litter that a given near-litter is near to in the type.
    The notation \( N^\circ \) refers to this litter; this is not a computation but an extraction of data.
\end{remark}
\begin{definition}
    The \emph{local cardinal} of a litter \( L \) is the set of near-litters \( N \) such that \( N^\circ = L \).
\end{definition}
\begin{lemma}
    There are \( \#\mu \) near-litters to any given litter.
    Alternatively, each local cardinal has cardinality \( \#\mu \).
    In particular, there are \( \#\mu \) near-litters.
\end{lemma}
\begin{definition}
    A \emph{near-litter permutation} is
    \begin{itemize}
        \item a permutation \( \pi_a \colon \tau_\bot \to \tau_\bot \);
        \item a permutation \( \pi_\ell \colon \mathsf{litter} \to \mathsf{litter} \);
        \item such that if \( N \) is a near-litter to \( L \), the pointwise image of \( \pi_a \) on \( N \) is a near-litter to \( \pi_\ell(L) \).
    \end{itemize}
\end{definition}
\begin{remark}
    We track the litter permutation associated to a near-litter permutation explicitly for convenience.
\end{remark}
\begin{lemma}
    Near-litter permutations form a group, with actions on atoms, litters, and near-litters.
\end{lemma}

\subsection{Structural permutations}

\begin{definition}
    An \emph{\( \alpha \)-structural permutation} is
    \begin{itemize}
        \item if \( \alpha = \bot \), a near-litter permutation;
        \item otherwise, a dependent product such that for each \( \beta : \lambda^\bot \) with \( \beta < \alpha \), we have a \( \beta \)-structural permutation.
    \end{itemize}
    The type of \( \alpha \)-structural permutations is written \( S_\alpha \).
\end{definition}
\begin{remark}
    This is a type constructed with well-founded recursion.
    It requires many lemmas to use effectively, such as an explicit equivalence between \( \bot \)-structural permutations and near-litter permutations.
\end{remark}
\begin{lemma}
    \( \alpha \)-structural permutations form a group, which acts on \( \tau_\alpha^\star \).
    For \( \beta < \alpha \), there is a natural group homomorphism from \( S_\alpha \) to \( S_\beta \), called the \emph{derivative map}.
    This derivative map can be used on paths in the quiver on type indices, and it is functorial and preserves multiplication.
    If \( \pi \) is an \( \alpha \)-structural permutation, we write \( \pi_A \) for the \( A \)-derivative of \( \pi \), where \( A \) is a path from \( \alpha \) to \( \beta \) in \( \lambda^\bot \).
\end{lemma}

\subsection{Supports}

\begin{definition}
    An \emph{\( \alpha \)-support condition} is an atom or a near litter, together with an \( \alpha \)-extended index.
\end{definition}
\begin{lemma}
    There are \( \#\mu \) \( \alpha \)-support conditions.
    \( \alpha \)-structural permutations act on \( \alpha \)-support conditions by setting \( \pi(x, A) = (\pi_A(x), A) \).
\end{lemma}
\begin{definition}
    Let \( \tau \) be a type, and \( G \) be a group that has multiplicative actions on \( \alpha \)-support conditions and \( \tau \).
    A \emph{support for \( x \)} is
    \begin{itemize}
        \item a small \emph{carrier set} of \( \alpha \)-support conditions;
        \item such that if the action of \( G \) fixes each element of the carrier, the action of \( G \) also fixes \( x \).
    \end{itemize}
    An element of \( \tau \) is \emph{supported} if it has some support.
\end{definition}
\begin{remark}
    The group \( G \) will be instantiated with structural permutations and allowable permutations.
    The type \( \tau \) will be instantiated with the types of tangles we obtain from the inductive hypothesis and the types of tangles we construct explicitly.
\end{remark}
\begin{lemma}
    There are at most \( \#\mu \) supports for a given \( x : \tau \).
\end{lemma}

\section{Tangle construction}

\subsection{Inductive hypotheses}

\begin{definition}
    Let \( \alpha : \lambda^\bot \).
    \emph{Core tangle data at level \( \alpha \)} is
    \begin{itemize}
        \item a type of \emph{tangles} \( \tau_\alpha \);
        \item a type of \emph{allowable permutations} \( A_\alpha \);
        \item such that \( A_\alpha \) is a group;
        \item a group homomorphism \( A_\alpha \to S_\alpha \);
        \item a group action of \( A_\alpha \) on \( \tau_\alpha \);
        \item for each \( t : \tau_\alpha \), a support for \( t \) under the action of \( A_\alpha \), called its \emph{designated support}.
    \end{itemize}
\end{definition}
\begin{remark}
    The homomorphism \( A_\alpha \to S_\alpha \) is applied implicitly where needed.
\end{remark}
\begin{definition}
    Let \( \alpha : \lambda^\bot \), and suppose we have core tangle data at \( \alpha \).
    \emph{Positioned tangle data at level \( \alpha \)} is an injective \emph{position} function \( \iota_\alpha \colon \tau_\alpha \to \mu \).
\end{definition}
\begin{remark}
    This is separated from core tangle data because, while core tangle data is quite easy to construct at a given level, constructing the positioned tangle data requires the freedom of action theorem.
\end{remark}
\begin{definition}
    Let \( \alpha : \lambda \), and suppose we have core tangle data at \( \alpha \).
    \emph{Almost tangle data at level \( \alpha \)} (rename this!) is
    \begin{itemize}
        \item an injection \( a_\alpha \) from the type of atoms into \( \tau_\alpha \) called the \emph{typed atom map};
        \item an injection \( N_\alpha \) from the type of near-litters to \( \tau_\alpha \) called the \emph{typed near-litter map};
        \item an injection \( p_\alpha \) from \( \tau_\alpha \) to the type of pretangles \( \tau_\alpha^\star \);
        \item where all such maps are equivariant with respect to \( A_\alpha \).
    \end{itemize}
\end{definition}
\begin{definition}
    If we have almost tangle data at \( \beta \) and \( \alpha \) where \( \beta < \alpha \), there is a membership relation between \( \tau_\beta \) and \( \tau_\alpha \) by mapping them to \( \tau_\beta^\star \) and \( \tau_\alpha^\star \), which has such a membership relation.
\end{definition}
\begin{definition}
    \emph{Position data} is an injection \( \iota_a \) from the type of atoms into \( \mu \).
\end{definition}
\begin{remark}
    This is the position of a typed singleton in the position function at any level.
\end{remark}
\begin{definition}
    Let \( \alpha : \lambda \), and suppose we have core tangle data, positioned tangle data, and almost tangle data at \( \alpha \), as well as position data.
    Then, \emph{tangle data at level \( \alpha \)} is
    \begin{itemize}
        \item for each atom \( a \), a proof that \( \iota_\alpha(a_\alpha(a)) = \iota_a(a) \);
        \item for each atom \( a \), a proof that \( \iota_\alpha(N_\alpha(L)) < \iota_a(a) \) where \( a \) is contained in the litter set of \( L \);
        \item for each near-litter \( N \), a proof that \( \iota_\alpha(N_\alpha(N^\circ)) \leq \iota_\alpha(N_\alpha(N)) \);
        \item for each near-litter \( N \) and atom \( a \in N\,\triangle\,N^\circ \), a proof that \( \iota_a(a) < \iota_\alpha(N_\alpha(N)) \);
        \item for each \( t : \tau_\alpha \) that is not a typed singleton or typed near-litter, and each support condition \( (x,A) \) in the designated support of \( t \), a proof that \( \iota_\alpha(a_\alpha(x)) \leq \iota_\alpha(t) \) or \( \iota_\alpha(N_\alpha(x)) \leq \iota_\alpha(t) \) depending on the value of \( x \).
        \item and some other conditions that aren't completely solidified yet (at least in type theory).
    \end{itemize}
    TODO: We probably want to put the typed near litter position function into the position data, so that we can keep track of it independent of \( \alpha \).

    Note on `condition 4' from \texttt{retangled.pdf}: if we have to enforce the \( \iota_\ast(X_\alpha) \geq \iota_\ast(X_0) \) condition, this would probably add quite a lot of complexity, because we don't currently have the ability to take sets \( X_0 \) and turn them into things in \( X_\alpha \).
\end{definition}
\begin{remark}
    This will be constructed for all proper type indices \( \alpha \).
\end{remark}
\begin{definition}
    We have core and positioned tangle data for \( \bot \) as follows.
    \begin{itemize}
        \item \( \tau_\bot \) is the type of atoms;
        \item \( A_\bot \) is the type of near-litter permutations;
        \item the designated support of each atom is \( \qty{(a, \mathsf{nil})} \);
        \item the position function is arbitrary.
    \end{itemize}
\end{definition}
\begin{definition}
    Let \( \alpha : \lambda \).
    \emph{Cumulative (core, positioned, almost) tangle data below level \( \alpha \)} is (core, positioned, almost) tangle data at all proper type indices below level \( \alpha \).
\end{definition}
\begin{ih}
    Suppose we are constructing tangles at level \( \alpha \).
    We assume that we have cumulative tangle data (of all kinds) below level \( \alpha \).
\end{ih}
\begin{remark}
    When accessing the tangle data in proofs, we want to ensure that \( \tau_\bot \) is always known to be the type of atoms, and \( A_\bot \) is always known to be the type of near-litter permutations.
    To enforce this, the accessor functions for tangle data at \( \beta \) first checks if \( \beta = \bot \); if this is true, we return the known tangle data at \( \bot \), and otherwise, we return the instance from the cumulative tangle data assumption.
\end{remark}

\subsection{Codes}

\begin{definition}
    An \emph{\( \alpha \)-code} is a type index \( \beta : \lambda_\alpha \) and a set of \( \beta \)-tangles.
\end{definition}

\subsection{\( f \)-maps}

\begin{lemma}
    Let \( \alpha, \beta \) be types, where \( \alpha \) is well-ordered.
    Let \( D \colon \alpha \to \mathcal P \beta \) assign a \emph{denied set} to each element of \( \alpha \).
    Suppose that for each \( x : \alpha \), \( \#\qty{y \mid y < x} + \#(D (x)) < \#\beta \).
    Then, there is an injective function \( f \colon \alpha \to \beta \) such that \( f(x) \not\in D(x) \) for each \( x : \alpha \).
\end{lemma}
\begin{proof}
    We explicitly construct such a function.
    Let \( x \in \alpha \).
    The set \( \qty{f(y) \mid y < x} \cup D(x) \) has cardinality strictly smaller than \( \#\beta \), so there exists an element of \( \beta \) outside this set that we will assign to \( f(x) \).
\end{proof}
In this section, let \( \beta : \lambda^\bot, \gamma : \lambda \), and suppose we have positioned tangle data at \( \beta \) and positioned and almost tangle data at \( \gamma \), with \( \beta \neq \gamma \).
\begin{definition}
    Let \( i : \mu \) and \( t : \tau_\beta \).
    We say that \( i \) is \emph{\( f \)-denied} by \( t \) if
    \begin{itemize}
        \item there is a near-litter \( N \) to the litter \( \langle i, \beta, \gamma \rangle \) such that \( \iota_\gamma(N_\gamma(N)) \leq \iota_\beta(t) \); or
        \item \( \beta = \bot \) and \( \iota_\gamma(N_\gamma(\langle i, \bot, \gamma \rangle)) \leq \iota_a(t) \).
    \end{itemize}
\end{definition}
\begin{lemma}
    Let \( t : \tau_\beta \).
    Then,
    \[ \#\qty{s \mid \iota_\beta(s) < \iota_\beta(t)} + \#\qty{i \mid i \text{ is \( f \)-denied by } t} < \#\mu \]
\end{lemma}
\begin{definition}
    The function \( f_{\beta,\gamma} \colon \tau_\beta \to \mathsf{litter} \) is defined by \( \langle f, \beta, \gamma \rangle \) where \( f \colon \tau_\beta \to \mu \) is an injective function constructed using the above lemma such that \( f(x) \) is not \( f \)-denied by \( x \) for each \( x \).
\end{definition}
\begin{lemma}
    For \( t : \tau_\beta \) and \( N \) a near-litter to \( f_{\beta,\gamma}(t) \), we have \( \iota_\beta(x) < \iota_\gamma(N_\gamma(N)) \).
    If \( \beta = \bot \), we also have \( \iota_a(t) < \iota_\gamma(N_\gamma(f_{\bot,\gamma}(a))) \).
\end{lemma}

\subsection{\( A \)-maps}

Let \( \alpha : \lambda, \beta : \lambda_\alpha, \gamma : \lambda^\bot_\alpha, \beta \neq \gamma \).
Suppose we have positioned tangle data at \( \gamma \) and positioned and almost tangle data at \( \beta \).
\begin{definition}
    The function \( A_{\gamma,\beta} \colon \mathcal P \tau_\gamma \to \mathcal P \tau_\beta \) is defined by
    \[ A_{\gamma,\beta}(S) = \qty{N_\beta(N) \mid N \in \bigcup_{t \in S} \qty[f_{\gamma,\beta}(t)]} \]
    where \( [L] \) denotes the local cardinal of \( L \).
\end{definition}
\begin{lemma}
    The \( A_{\gamma,\beta} \) for varying \( \gamma \) are injective and have disjoint ranges.
\end{lemma}
\begin{lemma}
    Let \( S : \mathcal P \tau_\gamma \) be a nonempty set of \( \gamma \)-tangles.
    Then, \( \min_{t \in S} \iota_\gamma(t) < \min_{t \in A_{\gamma,\beta}(S)} \iota_\beta(t) \).
\end{lemma}
\begin{definition}
    We define the \emph{extension function} \( E_{\beta,\gamma} \colon \mathcal P \tau_\beta \to \mathcal P \tau_\gamma \) by \( A_{\beta,\gamma} \) if \( \beta \neq \gamma \), and the identity function otherwise.
\end{definition}
\begin{definition}
    Let \( A_\beta \) be the function from \( \alpha \)-codes to \( \alpha \)-codes given by \( A_\beta(\gamma, S) = (\beta, E_{\gamma,\beta}(S)) \).
\end{definition}
\begin{definition}
    If \( c = (\beta, S) \) is an \( \alpha \)-code, we define the \emph{code position} to be \( \iota_c(c) = \min_{t \in S} \iota_\beta(t) \).
\end{definition}
\begin{lemma}
    Let \( c \) be an \( \alpha \)-code.
    Then, \( \iota_c(c) < \iota_c(A_\beta(c)) \).
\end{lemma}
\begin{definition}
    We define the relation \( \leadsto \) on \( \alpha \)-codes by defining \( c \leadsto A_\beta(c) \) when \( c = (\gamma, S)\) and \( \beta \neq \gamma \).
\end{definition}
\begin{lemma}
    If \( d_1, d_2 \leadsto c \), then \( d_1 = d_2 \).
    If \( c \leadsto d_1, d_2 \), then \( d_1 = d_2 \).
    The relation \( \leadsto \) is well-founded.
\end{lemma}

\subsection{Equivalence of codes}

\begin{definition}
    We define inductively that an \( \alpha \)-code \( c \) is
    \begin{itemize}
        \item \emph{even} if for all \( d \leadsto c \), \( d \) is odd;
        \item \emph{odd} if there exists \( d \leadsto c \) such that \( d \) is even.
    \end{itemize}
\end{definition}
\begin{lemma}
    The map \( A_\beta \) swaps the parity of a code \( (\gamma, S) \) if \( \beta \neq \gamma \).
    Empty codes are even if and only if their extension is \( \bot \).
    Singleton codes are even.
\end{lemma}
\begin{definition}
    We define the relation of \emph{equivalence} between \( \alpha \)-codes inductively by
    \begin{itemize}
        \item \( c \equiv c \);
        \item \( A_\beta(c) \equiv c \) where \( c = (\gamma, S) \) and \( \beta \neq \gamma \);
        \item \( c \equiv A_\beta(c) \) where \( c = (\gamma, S) \) and \( \beta \neq \gamma \); or
        \item \( A_\beta(c) \equiv A_\gamma(c) \) where \( c = (\delta, S) \) and \( \beta \neq \delta, \gamma \neq \delta \).
    \end{itemize}
\end{definition}
\begin{lemma}
    This is an equivalence relation.
    All empty codes are equivalent.
    If \( (\gamma, S) \equiv (\gamma, T) \) then \( S = T \).
    There exists exactly one even code in any equivalence class.
\end{lemma}

\subsection{Allowable permutations}

% assumptions?

\begin{definition}
    An \emph{\( \alpha \)-semiallowable permutation} is a dependent product such that for each \( \beta : \lambda^\bot_\alpha \), we have a \( \beta \)-allowable permutation.
    The type of \( \alpha \)-semiallowable permutations is written \( Q_\alpha \) (we probably want better naming than this).
\end{definition}
\begin{lemma}
    There is a multiplicative action of \( Q_\alpha \) on \( \tau_\beta \) for all \( \beta : \lambda^\bot_\alpha \).
    There is a natural homomorphism \( d_{\alpha,\beta} \colon Q_\alpha \to A_\beta \) for each \( \beta : \lambda^\bot_\alpha \), and we write \( \pi_\beta = d_{\alpha,\beta}(\pi) \).
    There is a homomorphism \( Q_\alpha \to S_\alpha \), giving it more multiplicative actions.
    Semiallowable permutations act on \( \alpha \)-codes by \( \pi(\gamma, S) = (\gamma, \pi(S)) \).
\end{lemma}
\begin{definition}
    An \emph{\( \alpha \)-allowable permutation} is an \( \alpha \)-semiallowable permutation whose action on codes preserves code equivalence, so \( c \equiv d \iff \pi(c) \equiv \pi(d) \).
    The type is written \( P_\alpha \).
\end{definition}
\begin{lemma}
    Allowable permutations act on everything that semiallowable permutations do.
\end{lemma}
\begin{theorem}[coherence of allowable permutations]
    Let \( t : \tau_\beta \) and \( \beta \neq \gamma \), and let \( \pi : P_\alpha \).
    Then,
    \[ (\pi_\gamma)_\bot(f_{\beta,\gamma}(t)) = f_{\beta,\gamma}(\pi_\beta(t)) \]
    Note that \( (\pi_\gamma)_\bot \) first computes the \( \beta \)-allowable permutation \( \pi_\gamma \) using the \( d_{\alpha,\gamma} \) map, then computes its \( \bot \)-derivative by interpreting \( \pi_\gamma \) as a \( \gamma \)-structural permutation; the latter coercion exists by the core tangle data inductive hypothesis.
    Let \( S : \mathcal P \tau_\beta \).
    Then,
    \[ \pi_\gamma(A_{\beta,\gamma}(S)) = A_{\beta,\gamma}(\pi_\beta(S)) \]
    Let \( c = (\gamma, S) \) be a code with \( \beta \neq \gamma \).
    Then,
    \[ \pi(A_\gamma(c)) = A_\gamma(\pi(c)) \]
    If \( c \) and \( d \) are codes, then \( c \leadsto d \iff \pi(c) \leadsto \pi(d) \).
    \( c \) is even if and only if \( \pi(c) \) is even.
\end{theorem}

\subsection{Tangles}

\begin{definition}
    An \emph{extension collection} is a dependent product such that for each \( \beta : \lambda_\alpha \). we have a set of \( \beta \)-tangles.
    We write \( e_\beta \) for this set of \( \beta \)-tangles, where \( e \) is the extension collection.
\end{definition}
\begin{definition}
    A \emph{preference} of an extension collection \( e \) is
    \begin{itemize}
        \item a set of atoms \( X : \mathcal P \tau_\bot \) such that for all \( \gamma : \lambda_\alpha \), we have \( A_{\bot,\gamma}(X) = e_\gamma \); or
        \item a proper type index \( \beta : \lambda_\alpha \) such that \( (\beta, e_\beta) \) is an even code, and for all \( \gamma : \lambda_\alpha \) where \( \beta \neq \gamma \), \( A_{\beta,\gamma}(e_\beta) = e_\gamma \).
    \end{itemize}
\end{definition}
\begin{definition}
    A \emph{semitangle} is an extension collection with a preference.
    If \( s = (e, p) \) is a semitangle, we write \( s_\gamma \) to abbreviate \( e_\gamma \), and \( s_{\mathsf{pref}} \) for \( p \).
    % TODO: \iota_a and \iota_c using mathsf?
\end{definition}
\begin{lemma}
    There is a membership relation between \( \gamma \)-tangles and \( \alpha \)-semitangles, for all \( \gamma : \lambda_\alpha \), by considering its extension collection.
    Each semitangle has an even code representing it, and every even code gives a semitangle.
\end{lemma}
\begin{theorem}
    Semitangles are extensional at \emph{each} \( \gamma : \lambda_\alpha \).
    More precisely, if \( s_1, s_2 \) are semitangles and \( \gamma : \lambda_\alpha \), then \( (s_1)_\gamma = (s_2)_\gamma \) implies \( s_1 = s_2 \).
    In addition, if \( \alpha = 0 \), semitangles are extensional at level \( \bot \).
\end{theorem}
\begin{lemma}
    There is a multiplicative action of allowable permutations on semitangles.
    Allowable permutations commute with taking extensions of semitangles, and with the membership relation.
\end{lemma}
\begin{definition}
    An \emph{\( \alpha \)-new tangle} is a semitangle that is supported under the action of \( \alpha \)-allowable permutations.
\end{definition}
\begin{lemma}
    There are new tangles representing typed near-litters, typed singletons, and typed small sets of supported \( \beta \)-tangles for \( \beta : \lambda_\alpha^\bot \).
\end{lemma}
\begin{lemma}
    Allowable permutations act on new tangles.
\end{lemma}

\section{Freedom of action}

\subsection{Support condition constraints}

\begin{definition}
    We define the \emph{constrains} relation \( \prec \) on \( \alpha \)-support conditions by
    \begin{itemize}
        \item \( (L, A) \prec (a, A) \) where \( a \) is an element of the litter set of \( L \);
        \item \( (N^\circ, A) \prec (N, A) \) where \( N \) is a near-litter that is not a litter;
        \item \( (a, A) \prec (N, A) \) where \( a \in N\,\triangle\,N^\circ \) and \( N \) is a near-litter;
        \item
            if \( A \) is a path from \( \alpha \) to \( \beta \),
            \( t : \tau_\gamma \) is a \( \gamma \)-tangle where \( \gamma : \lambda^\bot \) and \( \gamma < \beta \),
            \( (x, B) \) is an element of the designated \( \gamma \)-support of \( t \),
            and \( \delta < \beta \) is a proper type index not equal to \( \gamma \),
            then
            \[ (x, A \gg (\beta \longrightarrow \gamma) \gg B) \prec (f_{\gamma,\delta}(t), A \gg (\beta \longrightarrow \delta) \gg (\delta \longrightarrow \bot)) \]
        \item if \( A \) is a path from \( \alpha \) to \( \beta \), \( \gamma < \beta \) is a proper type index, and \( a : \tau_\bot \) is an atom, then
        \[ (a, A \gg (\beta \longrightarrow \bot)) \prec (f_{\bot,\delta}(a), A \gg (\beta \longrightarrow \delta) \gg (\delta \longrightarrow \bot)) \]
    \end{itemize}
\end{definition}
\begin{definition}
    We define a well-ordering on support conditions by \( (x, A) < (y, B) \) where \( \iota(x) < \iota(y) \) under the appropriate typed singleton or typed near-litter map, but if \( \iota(x) = \iota(y) \), we say \( (x, A) < (y, B) \) if \( A < B \) for a fixed well-ordering of extended type indices.
\end{definition}
\begin{lemma}
    \( \prec \) is well-founded, because \( (x, A) \prec (y, B) \) implies \( (x, A) < (y, B) \).
\end{lemma}
\begin{definition}
    The \emph{constrains closure} of a support is the downward closure of the support under \( \prec \), where we delete all near-litter support conditions \( (N, A) \) where \( N \) is not precisely the litter set of some litter.
\end{definition}
\begin{lemma}
    The constrains closure of a support is small.
\end{lemma}

\subsection{Local permutations}

\begin{definition}
    Let \( \alpha \) be a type.
    A \emph{local permutation} of \( \alpha \) is
    \begin{itemize}
        \item a pair of functions \( f, g \colon \alpha \to \alpha \);
        \item a \emph{domain} set of elements \( A : \mathcal P \alpha \);
        \item a proof that \( f(A) \subseteq A \) and \( g(A) \subseteq A \);
        \item a proof that \( g(f(a)) = a = f(g(a)) \) for all \( a \in A \).
    \end{itemize}
    If \( \pi^0 \) is a local permutation, then we write \( \dom \pi^0 \) for \( A \), \( \pi^0(a) \) for \( f(a) \), and \( (\pi^0)^{-1}(a) \) for \( g(a) \).
\end{definition}
\begin{lemma}
    We can define a local permutation by the piecewise action of two local permutations if the domains are disjoint.
\end{lemma}
\begin{definition}
    We define a preorder on the type of local permutations on a type \( \alpha \) by defining \( \pi^0 \leq \rho^0 \) if \( \dom \pi^0 \subseteq \dom \rho^0 \) and the actions of the permutations agree on \( \dom \pi^0 \).
\end{definition}

\subsection{Completing orbits}

\begin{theorem}
    Let \( f \colon \alpha \to \alpha \) be a function, and let \( S, T : \mathcal P\alpha \) be subsets of \( \alpha \) such that \( S \cup f(S) \) and \( T \) are disjoint.
    Let \( f \) be injective on \( S \).
    Suppose further that \( \#(S\,\triangle\,f(S)) \leq \#T \), and that \( T \) is infinite.
    Then, there exists a local permutation \( \pi^0 \) of \( \alpha \) such that
    \begin{itemize}
        \item \( \dom \pi^0 = S \cup f(S) \cup U \) where \( U \subseteq T \) is a set of cardinality \( \aleph_0 \cdot \#(S\,\triangle\,f(S)) \);
        \item \( \pi^0(x) = f(x) \) for all \( x \in S \).
    \end{itemize}
\end{theorem}
\begin{proof}
    First, note that as \( \#(S\,\triangle\,f(S)) \leq \#T \) and \( \aleph_0 \leq \#T \), we have room for such a set \( U \) of cardinality \( \aleph_0 \cdot \#(S\,\triangle\,f(S)) \) inside \( T \); we choose such a set arbitrarily.
    We construct the equivalence
    \[ U \simeq (\mathbb N \times (S \setminus f(S))) \oplus (\mathbb N \times (f(S) \setminus S)) \]
    with left injection \( \mathrm{inl} \colon \mathbb N \times (S \setminus f(S)) \hookrightarrow U \) and right injection \( \mathrm{inr} \colon
    \mathbb N \times (f(S) \setminus S) \hookrightarrow U \).
    In this way, we allocate room in \( U \) for the new images and preimages of elements of \( S\,\triangle\,f(S) \) that we will define.
    The resulting local permutation \( \pi^0 \) will perform the following maps of sets.
    % https://q.uiver.app/?q=WzAsMTIsWzAsMCwiXFxjZG90cyJdLFsxLDAsIlxcbWF0aHJte2lubH0oMixcXHN0YXIpIl0sWzIsMCwiXFxtYXRocm17aW5sfSgxLFxcc3RhcikiXSxbMywwLCJcXG1hdGhybXtpbmx9KDAsXFxzdGFyKSJdLFs0LDAsIlMgXFxzZXRtaW51cyBmKFMpIl0sWzUsMCwiXFxkb3RzIl0sWzEsMSwiXFxkb3RzIl0sWzIsMSwiZihTKSBcXHNldG1pbnVzIFMiXSxbMywxLCJcXG1hdGhybXtpbnJ9KDAsXFxzdGFyKSJdLFs0LDEsIlxcbWF0aHJte2lucn0oMSxcXHN0YXIpIl0sWzUsMSwiXFxtYXRocm17aW5yfSgyLFxcc3RhcikiXSxbNiwxLCJcXGNkb3RzIl0sWzAsMV0sWzEsMl0sWzIsM10sWzMsNF0sWzQsNSwiZiJdLFs2LDcsImYiXSxbNyw4XSxbOCw5XSxbOSwxMF0sWzEwLDExXV0=
    \[\begin{tikzcd}
        \cdots & {\mathrm{inl}(2,\star)} & {\mathrm{inl}(1,\star)} & {\mathrm{inl}(0,\star)} & {S \setminus f(S)} & \dots \\
        & \dots & {f(S) \setminus S} & {\mathrm{inr}(0,\star)} & {\mathrm{inr}(1,\star)} & {\mathrm{inr}(2,\star)} & \cdots
        \arrow[from=1-1, to=1-2]
        \arrow[from=1-2, to=1-3]
        \arrow[from=1-3, to=1-4]
        \arrow[from=1-4, to=1-5]
        \arrow["f", from=1-5, to=1-6]
        \arrow["f", from=2-2, to=2-3]
        \arrow[from=2-3, to=2-4]
        \arrow[from=2-4, to=2-5]
        \arrow[from=2-5, to=2-6]
        \arrow[from=2-6, to=2-7]
    \end{tikzcd}\]
    This will therefore complete the orbits of all elements in \( S \cup f(S) \) as required.
    We define the `shift right' function \( \mathrm{shr} \colon U \to \alpha \), which performs the action of all unmarked arrows in the above diagram, by
    \[ \mathrm{shr}(\mathrm{inl}(0, a)) = a;\quad \mathrm{shr}(\mathrm{inl}(n + 1, a)) = \mathrm{inl}(n, a);\quad \mathrm{shr}(\mathrm{inr}(n, a)) = \mathrm{inr}(n + 1, a) \]
    and the `shift left' function \( \mathrm{shr} \colon U \to \alpha \) symmetrically by
    \[ \mathrm{shl}(\mathrm{inl}(n, a)) = \mathrm{inl}(n + 1, a);\quad \mathrm{shl}(\mathrm{inr}(0, a)) = a;\quad \mathrm{shl}(\mathrm{inr}(n + 1, a)) = \mathrm{inr}(n, a) \]
    Then, we define \( \pi^0 \) by
    \[ \pi^0(x) = \begin{cases}
        \mathrm{shr}(x) & x \in U \\
        \mathrm{inr}(0, x) & x \in f(S) \setminus S \\
        f(x) & \text{otherwise}
    \end{cases} \]
    which has an inverse defined in terms of the `shift left' function.
\end{proof}

\subsection{Approximations}

\begin{definition}
    A litter \( L \) is \emph{\( A \)-inflexible} if \( A = B \gg (\beta \longrightarrow \delta) \gg (\delta \longrightarrow \bot) \), and there exists \( \gamma : \lambda^\bot \) with \( \gamma < \beta \) and \( \gamma \neq \delta \), and we have \( t : \tau_\gamma \) such that \( L = f_{\gamma,\delta}(t) \).
    A litter is \( A \)-flexible if it is not \( A \)-inflexible.
\end{definition}
\begin{definition}
    A \emph{near-litter approximation} is
    \begin{itemize}
        \item a local permutation \( \pi^0_a \) of atoms;
        \item a local permutation \( \pi^0_\ell \) of litters;
        \item such that \( L \cap \dom \pi^0_a \) is small for each litter \( L \).
    \end{itemize}
\end{definition}
\begin{remark}
    This definition is independent of our parameters at this level of the construction; it could have even been defined before core tangle data.
    The last condition ensures that if \( S_1, S_2 \) have \( S_1^\circ = S_2^\circ \), then at most one of \( S_1, S_2 \) can live in \( \dom \pi^0_s \).
\end{remark}
\begin{definition}
    A \emph{sublitter} is a litter \( L \) together with a subset \( S \) of the litter set of \( L \), such that \( L \setminus S \) is small (interpreting \( L \) as its litter set).
\end{definition}
\begin{remark}
    All sublitters are near-litters, and we interpret them as such.
    For instance, we use \( S^\circ \) to denote the litter associated to a sublitter.
\end{remark}
\begin{definition}
    The \emph{\( \pi^0 \)-largest sublitter} of a litter \( L \) is the set of atoms in the litter set of \( L \) but not in \( \dom \pi^0_a \).
    This is a sublitter since \( L \cap \dom \pi^0_a \) is small.
\end{definition}
\begin{definition}
    Let \( \pi^0 \) be a near-litter approximation.
    Then \( \pi^0 \) generates a local permutation \( \pi^0_s \) on sublitters where \( S \in \dom \pi^0_s \) if \( S \) is the largest sublitter of \( S^\circ \), and in this case, \( \pi^0_s(S) \) is the largest sublitter of \( \pi^0_\ell(S^\circ) \).
\end{definition}
\begin{definition}
    A near-litter permutation \( \pi : S_\bot \) has \emph{exception} \( a : \tau_\bot \) if \( \pi_a(a) \not\in \pi_\ell(L) \) or \( \pi^{-1}_a(a) \not\in \pi^{-1}_\ell(L) \), where \( a \) lies in the litter set of \( L \).
\end{definition}
\begin{definition}
    A near-litter approximation \( \pi^0 \) \emph{approximates} a near-litter permutation \( \pi : S_\bot \) if \( a \in \dom \pi^0_a \) implies \( \pi^0_a(a) = \pi_a(a) \), and \( L \in \dom \pi^0_\ell \) implies \( \pi^0_\ell(L) = \pi_\ell(L) \).
    In addition, we say that \( \pi^0 \) \emph{exactly approximates} \( \pi \) if \( \pi^0 \) approximates \( \pi \), and if \( a \) is an exception of \( \pi \), then \( a \in \dom \pi^0_a \).
\end{definition}
\begin{definition}
    We define a preorder on near-litter approximations by saying \( \pi^0 \leq \rho^0 \) if \( \pi^0_a \leq \rho^0_a \) and \( \pi^0_\ell \leq \rho^0_\ell \).
    If \( \pi^0 \leq \rho^0 \), we say \( \rho^0 \) \emph{extends} \( \pi^0 \).
\end{definition}
\begin{definition}
    A \emph{\( \beta \)-approximation} is a product that assigns a near-litter approximation to each \( \beta \)-extended index.
    We write \( \pi^0_A \) for the near-litter approximation given by the \( \beta \)-extended index \( A \).
    A \( \beta \)-approximation \( \pi^0 \) \emph{(exactly) approximates} a \( \beta \)-structural permutation \( \pi : S_\beta \) if \( \pi^0_A \) (exactly) approximates \( \pi_A \) for all \( A \).
\end{definition}
\begin{definition}
    An \emph{\( A \)-free near-litter approximation} is a near-litter approximation \( \pi^0 \) such that if \( L \in \dom \pi^0_\ell \), \( L \) is \( A \)-flexible.
    A \emph{\( \beta \)-free approximation} is a \( \beta \)-approximation \( \pi^0 \) where \( \pi^0_A \) is \( A \)-free for each \( A \).
\end{definition}
\begin{definition}
    Let \( c \) be a \( \beta \)-support condition.
    A \emph{\( c \)-hypothesis} \( H \) is
    \begin{itemize}
        \item a dependent product \( H_a \) such that for each atom \( a \) and \( \beta \)-extended index \( A \), if \( (a, A) \prec c \), we have an atom; and
        \item a dependent product \( H_n \) such that for each near-litter \( N \) and \( \beta \)-extended index \( A \), if \( (N, A) \prec c \), we have a near-litter.
    \end{itemize}
\end{definition}
\begin{lemma}
    Let \( F_a \) be a function that takes an atom \( a \), a \( \beta \)-extended index \( A \), and an \( (a, A) \)-hypothesis, and produces an atom.
    Let \( F_n \) be a function that takes a near-litter \( N \), a \( \beta \)-extended index \( A \), and an \( (N, A) \)-hypothesis, and produces a near-litter.
    Then there exist functions \( G_a, G_n \) such that
    \[ G_a(a, A) = F_a(a, A, (G_a, G_n));\quad G_n(N, A) = F_n(N, A, (G_a, G_n)) \]
\end{lemma}
\begin{proof}
    Construct the functions \( G_a, G_n \) by mutual well-founded recursion on the constrains relation on \( \beta \)-support conditions.
\end{proof}
This lemma will be used to construct the induced action of a \( \beta \)-free approximation on atoms and near-litters.

\subsection{Atom completion}

\begin{lemma}
    Let \( S, T \) be sublitters.
    Then there exists a bijection \( \pi_{S,T} \colon S \simeq T \).
\end{lemma}
\begin{proof}
    Their cardinalities are both \( \#\kappa \).
\end{proof}
\begin{definition}
    Let \( \pi^0 \) be a \( \beta \)-approximation.
    Then, we define the \emph{atom completion} of \( \pi^0 \) at \( \beta \)-extended index \( A \) to be a function \( (\widetilde\pi^0_A)_a \) on atoms.
    Let \( H \) be an \( (a, A) \)-hypothesis.
    Let \( L \) be the litter containing \( a \).
    Let \( S \) be the \( \pi^0_A \)-largest sublitter of \( L \), and \( T \) be the \( \pi^0_A \)-largest sublitter of \( H_n(L) \).
    Then, we define
    \[ (\widetilde\pi^0_A)_a(a) = \begin{cases}
        (\pi^0_A)_a(a) & a \in \dom (\pi^0_A)_a \\
        \pi_{S,T}(a) & \text{otherwise}
    \end{cases} \]
\end{definition}

\subsection{Flexible litter completion}
\begin{definition}
    Let \( \pi^0 \) be a near-litter approximation.
    Its \emph{flexible completion} is the local permutation on litters given piecewise by \( \pi^0_\ell \) on its domain, and by the identity function on flexible litters not in \( \dom \pi^0_\ell \).
\end{definition}

\subsection{Inflexible litter completion}

Let \( \gamma, \delta, \varepsilon \colon \lambda \) and suppose \( \delta < \gamma \), \( \varepsilon < \gamma \), \( \delta \neq \varepsilon \).
Let \( A \) be a path from \( \beta \) to \( \gamma \).
Let \( t \colon \tau_\delta \), and let \( H \) be a hypothesis for
\[ (f_{\delta,\varepsilon}(t), A \gg (\gamma \longrightarrow \varepsilon) \gg (\varepsilon \longrightarrow \bot)) \]
Let \( S \) be the constrains closure of the designated support of \( t \).
\( H_a \) and \( H_n \) are defined at all elements of \( S \).
\begin{definition}
    Let \( B \) be a \( \delta \)-extended index.
    Then, a litter \( L \) is \emph{banned} if any of the following hold.
    \begin{itemize}
        \item \( (a, B) \in S \), and \( a \in L \);
        \item \( (L, B) \in S \);
        \item \( H_a(a, B) \in L \) where \( (a, B) \in S \);
        \item \( H_n(N, B)^\circ = L \) where \( (N, B) \in S \);
        \item \( a \in H_n(N, B) \setminus H_n(N, B)^\circ \), \( a \in L \), and \( (N, B) \in S \).
    \end{itemize}
\end{definition}
Intuitively, a litter is banned if it interferes with \( S \) directly, or under the hypothesised action of \( \pi^0 \) on \( S \).
\begin{lemma}
    There are only a small number of banned litters.
\end{lemma}
\begin{definition}
    Define a \emph{sandbox litter} and a \emph{preimage litter} which are distinct and both unbanned.
\end{definition}
The sandbox litter is a litter used by the local permutation infrastructure to put the orbits of atoms.
The preimage litter is used to assign preimages to atoms in litters that we want nothing in \( S \) to map to.
\begin{definition}
    Let \( B \) be a \( \delta \)-extended index.
    Then an atom \( a \) is said to be \emph{without preimage} if
    \begin{itemize}
        \item there exists a litter \( L \) with \( (L, B) \in S \) such that \( a \in H_n(L, B)^\circ \);
        \item for all litters \( L \) with \( (L, B) \in S \), we have \( a \not\in H_n(L, B) \); and
        \item for all atoms \( b \) with \( (b, B) \in S \), we have \( a \neq H_a(b, B) \).
    \end{itemize}
\end{definition}
Atoms are without preimage if they are not mapped to by anything in \( S \), but they are in a litter near some near-litter that was in fact mapped to by something in \( S \).
Atoms without preimage need to have something that maps to it, so that the resulting map that we use in the freedom of action theorem actually maps to the correct near-litter.
\begin{lemma}
    There are only a small amount of atoms without preimage.
\end{lemma}
\begin{definition}
    Define a subset of the preimage litter that is put in correspondence with the set of atoms without preimage.
    Let \( P \) be the function from the preimage litter subset to the set of atoms without preimage.
\end{definition}
\begin{definition}
    Let \( B \) be a \( \delta \)-extended index.
    Let \( L \) be a litter where \( (L, B) \in S \).
    We say that an atom \( a \) is \emph{mapped outside \( L \)} if
    \begin{itemize}
        \item \( a \in H_n(L, B) \);
        \item \( a \not\in H_n(L, B)^\circ \);
        \item for all \( b \) with \( (b, B) \in S \), \( a \neq H_a(b, B) \).
    \end{itemize}
\end{definition}
The atoms mapped outside a litter \( L \) are the images of atoms in \( L \) under the completed action of \( \pi^0 \) that were not already mapped to by something in \( S \).
\begin{lemma}
    For each litter \( L \), there are only a small amount of atoms mapped outside it.
\end{lemma}
\begin{lemma}
    An atom cannot both be without preimage and mapped outside a litter.
\end{lemma}
\begin{definition}
    To each litter, we associate a subset which is to contain the atoms mapped outside it.
    We construct a subset of \( L \setminus \dom \pi^0_a \) with cardinality matching that of the set of atoms mapped outside \( L \).
    Let \( F_L \) be the function from this subset to the set of atoms mapped outside the litter.
\end{definition}
\begin{definition}
    The \emph{core atom map} is a function which takes an atom \( a \), an extended index \( B \), and an \( (a, B) \)-hypothesis \( H \), defined by
    \[ C(a, B) = \begin{cases}
        H_a(a, B) & (a, B) \in S \\
        P(a) & a \text{ is in the preimage litter subset} \\
        F_L(a) & a \text{ is in the mapped outside subset for a litter } L
    \end{cases} \]
    This is a function defined on the set of atoms \( a \) such that any of the following hold.
    \begin{itemize}
        \item \( (a, B) \in S \);
        \item \( a \) is in the preimage litter subset; or
        \item \( a \) is in the mapped outside subset for a litter \( L \).
    \end{itemize}
\end{definition}
\begin{lemma}
    The domain of the core atom map is small.
\end{lemma}
\begin{lemma}
    Let \( a \) be an atom in the domain of the core atom map.
    Then either \( a \) lies in a banned litter, or \( a \) is in the preimage litter subset.
\end{lemma}
\begin{lemma}
    Let \( C(a, B) \) be an atom in the image of the domain of the core atom map.
    Then \( C(a, B) \) lies in a banned litter.
\end{lemma}
\begin{definition}
    The \emph{atom map} is the local permutation of atoms given by completing orbits of the core atom map using the sandbox litter.
    However, if the core atom map fails to be injective, the atom map is instead the empty local permutation.
\end{definition}
\begin{remark}
    At this point in the proof, we cannot prove that the core atom map will always be injective, since it relies on properties of \( H \).
    We therefore have to hypothesise that this holds, and prove it later.
\end{remark}
\begin{lemma}
    The domain of the atom map is small, and contained within the union of
    \begin{itemize}
        \item the domain of the core atom map;
        \item the image of the domain of the core atom map; and
        \item the sandbox subset.
    \end{itemize}
\end{lemma}
\begin{definition}
    % TODO: rename
    The \emph{inflexible litter completion} is a \( \delta \)-approximation given by the atom map and flexible litter completion at each \( \delta \)-extended index \( B \).
\end{definition}
\begin{lemma}
    The inflexible litter completion is free if \( \pi^0 \) is free.
\end{lemma}
\begin{definition}
    We say \emph{freedom of action holds at level \( \gamma \)} if every \( \gamma \)-free approximation exactly approximates some \( \gamma \)-allowable permutation.
\end{definition}
\begin{definition}
    Suppose freedom of action holds at all levels \( \gamma < \beta \).
    Let \( L \) be a litter, \( A \) be a \( \beta \)-extended index, and \( H \) be an \( (L, A) \)-hypothesis.
    Then the \emph{litter completion} at \( (L, A) \) is
    \begin{itemize}
        \item \( f_{\delta, \varepsilon}(\pi(t)) \) if
        \[ L = f_{\delta, \varepsilon}(t);\quad A = B \gg (\gamma \longrightarrow \varepsilon) \gg (\varepsilon \longrightarrow \bot) \]
        and \( \pi \) is obtained by applying freedom of action at level \( \delta \) to the inflexible litter completion of \( \pi^0 \) at \( (L, B) \);
        \item \( f_{\bot, \varepsilon}(H_a(a, B \gg (\gamma \longrightarrow \bot))) \) if
        \[ L = f_{\bot, \varepsilon}(a);\quad A = B \gg (\gamma \longrightarrow \varepsilon) \gg (\varepsilon \longrightarrow \bot) \]
        \item the flexible completion at \( (L, A) \) otherwise.
    \end{itemize}
\end{definition}
\begin{lemma}
    Any choice of \( \pi \) in the definition above gives the same result for \( \pi(t) \).
\end{lemma}
\begin{proof}
    \( S \) supports \( t \), and any two choices of \( \pi \) agree on \( S \), so they must agree at \( t \).
\end{proof}
\begin{theorem}
    Suppose the litter completions of \( f_{\delta, \varepsilon}(t), f_{\delta, \varepsilon}(t') \), evaluated with the same extended index \( A = B \gg (\gamma \longrightarrow \varepsilon) \gg (\varepsilon \longrightarrow \bot) \), coincide.
    Then \( t = t' \).
\end{theorem}
\begin{proof}
    By injectivity of \( f_{\delta, \varepsilon} \), it suffices to show that \( \pi(t) = \pi'(t') \) implies \( t = t' \), where \( \pi \) is generated from a set \( S \), and \( \pi' \) is generated from a set \( S' \).
    Construct \( \overline\pi \) in the same way that \( \pi, \pi' \) were constructed, but use the set \( S \cup S' \) as the support.
    Then \( \pi(t) = \overline\pi(t) \) and \( \pi'(t') = \overline\pi(t') \) by the previous lemma.
    Thus, \( \overline\pi(t) = \overline\pi(t') \).
    But \( \overline\pi \) is a permutation, so \( t = t' \).
\end{proof}
\begin{remark}
    Technically, the permutations \( \pi, \pi' \) also depend on the hypotheses \( H, H' \).
    For this theorem, we assume that the hypotheses are \emph{compatible} in the sense that they agree wherever they are both defined.
\end{remark}

\subsection{Near-litter completion}

\begin{definition}
    Let \( N \) be a near-litter and \( A \) be a \( \beta \)-extended index.
    Then, the \emph{near-litter completion} at \( (N, A) \) is the near-litter with litter \( L \) given by the litter completion at \( (N^\circ, A) \), and with atom set given by
    \[ \mathrm{ls}(L) \cup \pi^0(N \setminus \mathrm{ls}(N^\circ)) \setminus \pi_{\mathrm{ls}(N^\circ), \mathrm{ls}(L)}(\mathrm{ls}(N^\circ) \setminus N) \]
    where \( \mathrm{ls} \) is the largest sublitter map.
\end{definition}

\subsection{Complete action}

\begin{definition}
    The \emph{complete action} of a \( \beta \)-free approximation \( \pi^0 \) on an atom or near-litter together with an extended index is given by the atom completion or the near-litter completion, respectively, constructed by well-founded recursion on hypotheses.
    We write \( \hat \pi^0_a, \hat \pi^0_n \) for the completed maps, and define \( \hat \pi^0_\ell \) on litters by \( \hat \pi^0_\ell(L) = \qty(\hat \pi^0_n(L))^\circ \).
\end{definition}
We now aim to show that this complete action defines a \( \beta \)-allowable approximation that \( \pi^0 \) exactly approximates.
\begin{lemma}
    \( \qty(\hat \pi^0_n(N))^\circ = \hat \pi^0_\ell(N^\circ) \).
\end{lemma}
\begin{proof}
    \( \qty(\hat \pi^0_n(N))^\circ \) is given by the litter completion at \( (N^\circ, A) \), which is precisely the definition of \( \hat \pi^0_\ell(N^\circ) \).
\end{proof}
\begin{lemma}
    \( \hat \pi^0_a(N) = \hat \pi^0_n(N) \).
\end{lemma}
\begin{definition}
    Let \( c \) be a \( \beta \)-support condition.
    We say that the completed action of \( \pi^0 \) is
    \begin{itemize}
        \item \( c \)-atom-injective if for all \( (a, B), (b, B) \prec c \), \( \hat \pi^0_a(a) = \hat \pi^0_a(b) \) implies \( a = b \);
        \item \( c \)-litter-injective if for all \( (L_1, B), (L_2, B) \prec c \), \( \hat \pi^0_\ell(L_1) = \hat \pi^0_\ell(L_2) \) implies \( L_1 = L_2 \);
        \item \( c \)-atom-surjective if for all \( (a, B) \prec c \), there exists \( b \) such that \( \hat \pi^0_a(b, B) = a \);
        \item \( c \)-litter-surjective if for all \( (L_1, B) \prec c \), there exists \( L_2 \) such that \( \hat \pi^0_a(L_2, B) = L_1 \).
    \end{itemize}
\end{definition}
\begin{lemma}
    Suppose the completed action is \( c \)-atom-injective and \( c \)-litter-injective.
    Then the completed action is atom-injective for all conditions \( d \preceq c \).
\end{lemma}
\begin{proof}
    Consider the four cases depending on whether \( a, b \) lie in \( \dom \pi^0_a \).
    If either lies in the domain, the lemma holds.
    If they both do not, they lie in a matching sublitter, but the sublitter bijection is injective.
\end{proof}
\begin{lemma}
    Suppose the completed action is \( c \)-atom-injective and \( c \)-litter-injective.
    Then the completed action is litter-injective for all conditions \( d \preceq c \).
\end{lemma}
\begin{proof}
    The only nontrivial part is the case where
    \[ \hat \pi^0_\ell(f_{\delta,\varepsilon}(t), B \gg (\gamma \longrightarrow \varepsilon) \gg (\varepsilon \longrightarrow \bot)) = \hat \pi^0_\ell(f_{\delta,\varepsilon}(t'), B \gg (\gamma \longrightarrow \varepsilon) \gg (\varepsilon \longrightarrow \bot)) \]
    The result \( f_{\delta,\varepsilon}(t) = f_{\delta,\varepsilon}(t') \) easily follows from the last theorem in the section on the inflexible litter completion.
\end{proof}
\begin{theorem}
    \( \hat \pi^0_a \) and \( \hat \pi^0_\ell \) are injective.
\end{theorem}
\begin{proof}
    Induction on support conditions, and use the previous two lemmas.
\end{proof}
\begin{lemma}
    Suppose the completed action is \( c \)-litter-surjective.
    Then the completed action is atom-surjective for all conditions \( d \preceq c \).
\end{lemma}
\begin{proof}
    Let \( a \) be an atom.
    If \( a \in \dom \pi^0_a \), it has a preimage in \( \dom \pi^0_a \).
    Otherwise, it is in the largest sublitter of some litter, and therefore has a preimage under the sublitter bijection.
\end{proof}
\begin{theorem}
    Let \( L = f_{\delta, \varepsilon}(t);\quad A = B \gg (\gamma \longrightarrow \varepsilon) \gg (\varepsilon \longrightarrow \bot) \), and suppose the completed action is \( (L, B) \)-atom-surjective and \( (L, B) \)-litter-surjective.
    Then there exists \( t' \colon \tau_\delta \) such that \( L = \hat \pi^0_\ell(f_{\delta,\varepsilon}(t'), A) \).
\end{theorem}
\begin{proof}
    Let \( S \) be the constrains closure of a support of \( t \), and let \( \qty(\hat \pi^0)^{-1}(S) \) be the inverse image of the support under the completed action, which exists by atom and litter surjectivity.
    Construct a \( \delta \)-allowable permutation \( \pi \) using this support.
    Then \( \qty(\hat \pi^0)^{-1}(S) \) supports \( t' = \pi^{-1}(t) \).
    So \( \hat\pi^0_\ell(f_{\delta,\varepsilon}(t'), A) = t \) as required.
\end{proof}
\begin{theorem}
    \( \hat \pi^0_a \) and \( \hat \pi^0_\ell \) are surjective.
\end{theorem}
\begin{proof}
    Apply the previous results, using induction on support conditions.
\end{proof}
\begin{corollary}
    \( \hat \pi^0 \) forms a near-litter permutation for each \( \beta \)-extended index \( A \), and thus gives a structural permutation.
\end{corollary}
\begin{lemma}
    \( \pi^0 \) exactly approximates the structural permutation given by \( \hat\pi^0 \).
\end{lemma}
\begin{lemma}
    Let \( t : \tau_\gamma \) and \( \gamma \neq \delta \).
    Suppose that \( \hat\pi^0 \) is the action of an allowable permutation at levels \( \gamma \) and \( \delta \).
    Then,
    \[ (\hat\pi^0_\delta)_\bot(f_{\gamma,\delta}(t)) = f_{\gamma,\delta}(\hat\pi^0_\gamma(t)) \]
    Hence, \( \hat\pi^0 \) is the action of an allowable permutation at all levels.
\end{lemma}
\begin{theorem}
    Freedom of action holds at all levels \( \beta \leq \alpha \).
\end{theorem}

\section{Weak approximation discussion}

\subsection{Definitions}

\begin{definition}
    A \emph{weak near-litter approximation} \( w \) is
    \begin{itemize}
        \item a partial function \( w_a \) from atoms to atoms with small domain,
        \item a partial function \( w_\ell \) from litters to near-litters with small domain, such that
        \item \( w_a \) is injective and no two images under \( w_\ell \) of distinct litters intersect, and
        \item \( w_a(a) \in w_\ell(L) \iff a \in L \) wherever \( w_a(a) \) and \( w_\ell(L) \) are both defined.
    \end{itemize}
    A \emph{weak \( \beta \)-structural approximation} is a function assigning a weak near-litter approximation to each \( \beta \)-extended index.
\end{definition}
A weak near-litter approximation can be thought of as a near-litter approximation that may not have complete orbits in its domain.
Note that we keep track of \emph{precise} images of litters, and therefore need the condition that \( w_a(a) \in w_\ell(L) \iff a \in L \).
Non-weak near-litter approximations handle this by only defining a rough image of each litter.
\begin{definition}
    Let \( w \) be a weak near-litter permutation.
    A litter \( L \) is \emph{banned} if any of the following hold.
    \begin{itemize}
        \item \( a \in \dom w_a \), and \( a \in L \);
        \item \( L \in \dom w_\ell \);
        \item \( w_a(a) \in L \) where \( a \in \dom w_a \);
        \item \( w_\ell(L')^\circ = L \) where \( L' \in \dom w_\ell \);
        \item \( a \in w_\ell(L') \setminus w_\ell(L')^\circ \), \( a \in L \), and \( L' \in \dom w_\ell \).
    \end{itemize}
\end{definition}
Intuitively, a litter is banned if it interferes with \( w \).
\begin{lemma}
    There are only a small number of banned litters.
\end{lemma}
For each weak near-litter approximation, we define a \emph{sandbox litter} which is an arbitrarily chosen litter that is not banned.
Already, we can define the completion of a weak near-litter approximation into a near-litter approximation.
\begin{definition}
    Let \( w \) be a weak near-litter approximation, and let \( p \) be a local permutation of litters.
    Its \emph{completion} relative to \( p \) is the near-litter approximation \( c(w) \) with litter map \( p \) and atom map given by completing orbits of \( w_a \).
\end{definition}
Note that \( w_\ell \) plays no part in this definition.
This is because near-litter approximations only need rough images of litters to be defined, and we know all of these \emph{a priori} without having to complete orbits of \( w_\ell \) somehow.
Of course, later results will require some level of coherence between \( w_\ell \) and \( p \).

\subsection{Weak near-litter approximations}

This subsection is devoted to proving results about \( c(w) \), and in particular how it relates to an arbitrary near-litter permutation \( \pi \) that \( c(w) \) exactly approximates.
We show that under sufficiently strong hypotheses, we have a large amount of control over the precise images of litters under the action of \( \pi \).
Note that trivially \( \pi(a) = w_a(a) \) wherever the latter is defined, as \( c(w) \) approximates it, and \( \dom w_a \subseteq \dom c(w)_a \).
\begin{definition}
    We say that \( w \) is \emph{precise} at a litter \( L \) in its domain if
    \begin{enumerate}
        \item \( w_\ell(L) \,\triangle\, w_\ell(L)^\circ \subseteq \rge w_a \);
        \item for all \( a \in \dom w_a \) with \( w_a(a) \in L \), we have \( w_a(a) \in \dom w_a \);
        \item \( \dom w_a \cap w_\ell(L) \subseteq \rge w_a \).
    \end{enumerate}
\end{definition}
The last two conditions can be abbreviated \( \dom w_a \cap w_\ell(L) = \rge w_a \cap w_\ell(L) \), although this statement is messier to work with in Lean.

This is a sufficient condition to exactly determine the precise image of \( L \) under \( \pi \).
These conditions are motivated as follows.
\begin{enumerate}
    \item Suppose an atom in \( w_\ell(L) \setminus w_\ell(L)^\circ \) were not mapped to by anything in \( \dom w_a \).
    \( \pi \) could then map something from an arbitrary litter to this point, giving the wrong image.
    Now suppose an atom in \( w_\ell(L)^\circ \setminus w_\ell(L) \) were not mapped to by anything in \( \dom w_a \)...
    \item Suppose this condition were not true, so there was an atom \( a \) mapped inside \( L \), but the image of \( a \) under \( \pi \) is unspecified.
    \( \pi \) will then map \( a \) to an arbitrary litter, but since it is inside \( L \), the image is supposed to be inside \( w_\ell(L) \).
    \item If no inverse image for an atom \( a \in w_\ell(L) \) is specified, it could be assigned outside \( L \).
\end{enumerate}
\begin{lemma}
    Let \( w \) be precise at \( L \in \dom w_\ell \).
    Then, if \( \pi(L)^\circ = w_\ell(L)^\circ \), we have \( \pi(L) = w_\ell(L) \).
\end{lemma}
This result strengthens knowledge about rough images litters under of \( \pi \) into knowledge about precise images of \( \pi \).

All of the work with the `mapped outside' and `without preimage' atoms goes directly into satisfying this condition.
We aim to show that any weak near-litter permutation can be strengthened by adding atoms into its domain in such a way that it becomes precise.

\subsection{Weak structural approximations}

Define that a weak near-litter approximation is \emph{precise} if it is precise at all litters in its domain.
Further define that a weak structural approximation if each weak near-litter approximation is precise.
Let \( \pi \) be a \( \beta \)-structural permutation, and let \( c(w) \) exactly approximate \( \pi \).
The previous results can then be stated as:
\begin{itemize}
    \item \( \pi_B(a) = w_B(a) \);
    \item if \( w \) is precise, \( \pi_B(L)^\circ = w_B(L)^\circ \) implies \( \pi_B(L) = w_B(L) \).
\end{itemize}
Let \( w, v \) be weak \( \beta \)-structural approximations, let \( c(w) \) exactly approximate an allowable permutation \( \pi \), and let \( c(v) \) exactly approximate an allowable permutation \( \rho \).
We aim to establish a sufficient condition for when \( \pi(t) = \rho(t) \) for some given \( t \in \tau_\beta \).
Certainly, we will need that \( w \) and \( v \) are both defined on a support of \( t \).
Since we want precise images of litters, we must first take the downward closure of the support under the `constrains' relation \( \prec \).
\begin{definition}
    A support condition is \emph{reduced} when it is an atom or a litter.
    The \emph{reduction} of a set \( S \) of support conditions is the set of reduced conditions that transitively constrain an element of \( S \).
\end{definition}
One can easily see that if \( S \) is small, its reduction is small.
\begin{definition}
    We say \( w \) \emph{supports} \( t \in \tau_\beta \) if all atoms and litters in the reduction of its designated support lie in the domain of \( w \).
\end{definition}
Passing to the reduction before requiring it in the domain of a weak approximation allows us to force the precise images of transitively constrained litters to be specified.
\begin{definition}
    \( w \) and \( v \) are \emph{compatible} for \( t \in \tau_\beta \) if \( w \) and \( v \) support \( t \), and they agree on the reduction of the designated support of \( t \).
\end{definition}
In order to force \( \pi(t) = \rho(t) \), we will require that \( w \) and \( v \) are compatible for \( t \).

There is another constraint that is not yet dealt with.
Currently, different levels of weak approximations do not cohere; in particular, weak approximations do not know about \( f \)-maps.
There is also no requirement that the images of litters agree with our local litter permutation \( p \) (which is now taken to be defined separately for each \( \beta \)-extended index).

Note that \( w \) has an action on support conditions where the given atom or near-litter is in its domain.
\begin{definition}
    We say that \( w \) is \emph{coherent} if
    \begin{itemize}
        \item \( p_B(L) = w_B(L)^\circ \) whenever both are defined;
        \item \( f_{\delta,\varepsilon}(\pi_{C \gg (\gamma \longrightarrow \delta)}(t)) = w_{C \gg (\gamma \longrightarrow \varepsilon) \gg (\varepsilon \longrightarrow \bot)}(f_{\delta,\varepsilon}(t))^\circ \) when \( C \) is a path from \( \beta \) to \( \gamma \) and \( t \in \tau_\delta \), given that the action of \( \pi \) agrees with the action of \( w \) on support conditions in the designated support of \( t \);
        \item \( f_{\bot,\varepsilon}(\pi_{C \gg (\gamma \longrightarrow \bot)}(a)) = w_{C \gg (\gamma \longrightarrow \varepsilon) \gg (\varepsilon \longrightarrow \bot)}(a)^\circ \) when \( C \) is a path from \( \beta \) to \( \gamma \) and \( a \in \tau_\bot \), given that the actions of \( \pi \) and \( w \) on \( a \) agree.
    \end{itemize}
\end{definition}
The weak structural approximations we create should all be coherent, and this should not be difficult to prove.
Note that whether a weak approximation is precise is a statement about atoms at a given extended index; whether a weak approximation is coherent is a statement about litters across different extended indices.
Arguably, the first condition could be separated into its own statement.
\begin{lemma}
    Let \( w \) be a weak \( \beta \)-structural approximation that is coherent.
    Suppose further that for each \( B \), all \( B \)-flexible litters lie in \( \dom p \).
    Let \( t \in \tau_\beta \) be a tangle that \( w \) supports.
    Suppose that \( L \) is a litter such that the actions of \( \pi \) and \( w \) agree on every condition transitively constraining \( (L, B) \), and that \( L \) transitively constrains some element of the designated support of \( t \).
    Then \( \pi_B(L) = w_B(L)^\circ \).
\end{lemma}
\begin{proof}
    Case analysis on \( B \)-flexibility of \( L \); the result follows easily from coherence.
    Proven in Lean modulo some annoying Lean-specific things.
\end{proof}
We now use the previous lemma about strengthening rough images into precise images.
\begin{lemma}
    Let \( w \) be a weak \( \beta \)-structural approximation that is precise and coherent.
    Suppose further that for each \( B \), all \( B \)-flexible litters lie in \( \dom p \).
    Let \( t \in \tau_\beta \) be a tangle that \( w \) supports.
    Then the actions of \( \pi \) and \( w \) agree on all support conditions in the designated support of \( t \).
\end{lemma}
\begin{proof}
    Induction on support conditions.
    Not spelled out here, it's proven in Lean.
\end{proof}
\begin{theorem}
    Let \( w, v \) be weak \( \beta \)-structural approximations that are precise and coherent, and are compatible for \( t \in \tau_\beta \).
    Suppose further that for each \( B \), all \( B \)-flexible litters lie in \( \dom p \).
    Then \( \pi(t) = \rho(t) \).
\end{theorem}
\begin{proof}
    The allowable permutation \( \pi^{-1} \rho \) fixes each support condition in the designated support of \( t \).
    Therefore, it fixes \( t \).
\end{proof}
The induced action on inflexible litters defined in the freedom of action theorem is \( c(w) \) for some \( w \).
Suppose we have an inflexible litter which is the \( f \)-map of some \( t \in \tau_\beta \).
By inductive hypothesis, we know the intended precise action on its designated support.
This forms a weak \( \beta \)-structural approximation \( w \).
Outside of the induction, we can prove \( w \) is coherent.
Inside, we intend to extend this \( w \) to something precise; outside, we will observe that this extension does not break coherence.
This extended \( w \) is completed and freedom of action is indctively applied to find \( \pi \).
The above theorem then says that adding extra atoms and litters into the original \( w \) does not change the action of \( \pi \) on \( t \).

This is all proven in Lean, ignoring some minor quirks to do with actions of \( \bot \)-allowable permutations versus near-litter permutations (which are clearly the same on paper).
Notably, the near-litter injectivity condition was never used; it probably follows from the other assumptions.

\end{document}
