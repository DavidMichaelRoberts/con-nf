\documentclass{article}

\usepackage{util}

\title{Con(NF)}
\author{Sky Wilshaw}

\begin{document}

\maketitle

\section{Setup}

\subsection{Model parameters}

\begin{definition}
    If \( \alpha \) is a type, \( \# \alpha \) is the cardinal representing the size of \( \alpha \).
    If \( \kappa \) is a cardinal, \( \mathsf{ord}(\kappa) \) is the ordinal given by \( \kappa \).
    Both of these operations are applied implicitly where required.
\end{definition}
\begin{param}
    Let \( \lambda \) be the type of \emph{proper type indices} with a well-ordering \( <_\lambda \).
    Assume that the order type of \( <_\lambda \) is \( \mathsf{ord}(\#\lambda) \), and \( \#\lambda \) is a limit cardinal.
    Let \( \kappa \) be a type where \( \#\kappa \) is an uncountable regular cardinal strictly larger than \( \#\lambda \).
    Let \( \mu \) be a type with a well-ordering \( <_\mu \).
    Assume that the order type of \( <_\mu \) is \( \mathsf{ord}(\#\mu) \).
    Assume that \( \#\mu \) is a strong limit cardinal creater than \( \#\kappa \), and \( \#\mu \) has cofinality at least \( \#\kappa \).
\end{param}
\begin{remark}
    These parameters can be satisfied with \( \lambda = \mathbb N \), \( \#\kappa = \aleph_1 \), \( \#\mu = \beth_{\omega_1} \).
\end{remark}
\begin{definition}
    A \emph{type index} is an element of \( \lambda \), or the symbol \( \bot \), representing a base type (also called `type \( -1 \)') below all types.
    The type of type indices is denoted \( \lambda^\bot \).
\end{definition}
\begin{lemma}
    Type indices are well-ordered with \( \bot \le \alpha \) for all \( \alpha : \lambda^\bot \), and \( \#\lambda^\bot = \#\lambda \).
\end{lemma}
\begin{definition}
    A \emph{litter} is a structure with
    \begin{itemize}
        \item an \emph{index} \( \nu : \mu \);
        \item a \emph{source type index} \( \beta : \lambda^\bot \);
        \item a \emph{target proper type index} \( \gamma : \lambda \);
        \item such that \( \beta \neq \gamma \).
    \end{itemize}
\end{definition}
\begin{lemma}
    There are \( \#\mu \) litters.
\end{lemma}
\begin{definition}
    An \emph{atom} is a litter together with an index in \( \kappa \).
\end{definition}
\begin{lemma}
    There are \( \#\mu \) atoms.
\end{lemma}
\begin{definition}
    A type or a set is \emph{small} if its cardinality is strictly smaller than \( \#\kappa \).
    Two sets are \emph{near} if their symmetric difference is small.
\end{definition}

\subsection{Pretangles}

\begin{definition}
    Let \( \alpha : \lambda^\bot \) be a type index.
    An \emph{\( \alpha \)-pretangle} is
    \begin{itemize}
        \item if \( \alpha = \bot \), an atom;
        \item otherwise, for each \( \beta : \lambda^\bot \) such that \( \beta < \alpha \), a set of \( \beta \)-pretangles.
    \end{itemize}
    We define \( \tau_\alpha^\star \) to be the type of \( \alpha \)-pretangles.
\end{definition}
\begin{definition}
    Let \( \beta < \alpha \) be type indices.
    Then there is a membership relation betweeen \( \tau_\beta^\star \) and \( \tau_\alpha^\star \).
\end{definition}

\subsection{Type indices}

\begin{definition}
    Let \( \alpha : \lambda \).
    We define the type \( \lambda_\alpha \) of proper type indices strictly below \( \alpha \), and \( \lambda_\alpha^\bot \) of type indices strictly below \( \alpha \).
\end{definition}
\begin{definition}
    A quiver structure is defined on \( \lambda^\bot \) by defining \( \alpha \longrightarrow \beta \) if \( \beta < \alpha \).
    An \emph{\( \alpha \)-extended index} is a path in this quiver from \( \alpha \) to \( \bot \).
    If \( A \) is a path from \( \alpha \) to \( \beta \) and \( B \) is a path from \( \beta \) to \( \gamma \), we denote their \emph{composition} by \( A \gg B \), a path from \( \alpha \) to \( \gamma \).
\end{definition}
\begin{remark}
    Paths are implemented like `snoc-lists'; extracting the last segment of a path is easy, and extracting the first is more difficult.
\end{remark}
\begin{lemma}
    There are at most \( \#\lambda \) \( \alpha \)-extended indices.
\end{lemma}

\subsection{Litters}

\begin{definition}
    The \emph{litter set} corresponding to a litter \( L \) is the set of atoms \( a = (L', i) \) where \( L = L' \).
    We transparently cast litters to litter sets as necessary (but not in reverse).
\end{definition}
\begin{lemma}
    The litter sets are pairwise disjoint and have cardinality \( \#\kappa \).
\end{lemma}
\begin{definition}
    A set \( N \) \emph{is a near-litter} to a litter \( L \) if it has small symmetric difference from the litter set of \( L \).
    A \emph{near-litter} is a litter \( L \) together with a set \( N \) that is a near-litter to \( L \).
\end{definition}
\begin{remark}
    We keep track of the litter that a given near-litter is near to in the type.
    The notation \( N^\circ \) refers to this litter; this is not a computation but an extraction of data.
\end{remark}
\begin{definition}
    The \emph{local cardinal} of a litter \( L \) is the set of near-litters \( N \) such that \( N^\circ = L \).
\end{definition}
\begin{lemma}
    There are \( \#\mu \) near-litters to any given litter.
    Alternatively, each local cardinal has cardinality \( \#\mu \).
    In particular, there are \( \#\mu \) near-litters.
\end{lemma}
\begin{definition}
    A \emph{near-litter permutation} is
    \begin{itemize}
        \item a permutation \( \pi_a \colon \tau_\bot \to \tau_\bot \);
        \item a permutation \( \pi_\ell \colon \mathsf{litter} \to \mathsf{litter} \);
        \item such that if \( N \) is a near-litter to \( L \), the pointwise image of \( \pi_a \) on \( N \) is a near-litter to \( \pi_\ell(L) \).
    \end{itemize}
\end{definition}
\begin{remark}
    We track the litter permutation associated to a near-litter permutation explicitly for convenience.
\end{remark}
\begin{lemma}
    Near-litter permutations form a group, with actions on atoms, litters, and near-litters.
\end{lemma}

\subsection{Structural permutations}

\begin{definition}
    An \emph{\( \alpha \)-structural permutation} is
    \begin{itemize}
        \item if \( \alpha = \bot \), a near-litter permutation;
        \item otherwise, a dependent product such that for each \( \beta : \lambda^\bot \) with \( \beta < \alpha \), we have a \( \beta \)-structural permutation.
    \end{itemize}
    The type of \( \alpha \)-structural permutations is written \( S_\alpha \).
\end{definition}
\begin{remark}
    This is a type constructed with well-founded recursion.
    It requires many lemmas to use effectively, such as an explicit equivalence between \( \bot \)-structural permutations and near-litter permutations.
\end{remark}
\begin{lemma}
    \( \alpha \)-structural permutations form a group, which acts on \( \tau_\alpha^\star \).
    For \( \beta < \alpha \), there is a natural group homomorphism from \( S_\alpha \) to \( S_\beta \), called the \emph{derivative map}.
    This derivative map can be used on paths in the quiver on type indices, and it is functorial and preserves multiplication.
    If \( \pi \) is an \( \alpha \)-structural permutation, we write \( \pi_A \) for the \( A \)-derivative of \( \pi \), where \( A \) is a path from \( \alpha \) to \( \beta \) in \( \lambda^\bot \).
\end{lemma}

\subsection{Supports}

\begin{definition}
    An \emph{\( \alpha \)-support condition} is an atom or a near litter, together with an \( \alpha \)-extended index.
\end{definition}
\begin{lemma}
    There are \( \#\mu \) \( \alpha \)-support conditions.
    \( \alpha \)-structural permutations act on \( \alpha \)-support conditions by setting \( \pi(x, A) = (\pi_A(x), A) \).
\end{lemma}
\begin{definition}
    Let \( \tau \) be a type, and \( G \) be a group that has multiplicative actions on \( \alpha \)-support conditions and \( \tau \).
    A \emph{support for \( x \)} is
    \begin{itemize}
        \item a small \emph{carrier set} of \( \alpha \)-support conditions;
        \item such that if the action of \( G \) fixes each element of the carrier, the action of \( G \) also fixes \( x \).
    \end{itemize}
    An element of \( \tau \) is \emph{supported} if it has some support.
\end{definition}
\begin{remark}
    The group \( G \) will be instantiated with structural permutations and allowable permutations.
    The type \( \tau \) will be instantiated with the types of tangles we obtain from the inductive hypothesis and the types of tangles we construct explicitly.
\end{remark}
\begin{lemma}
    There are at most \( \#\mu \) supports for a given \( x : \tau \).
\end{lemma}

\section{Tangle construction}

\subsection{Inductive hypotheses}

\begin{definition}
    Let \( \alpha : \lambda^\bot \).
    \emph{Core tangle data at level \( \alpha \)} is
    \begin{itemize}
        \item a type of \emph{tangles} \( \tau_\alpha \);
        \item a type of \emph{allowable permutations} \( A_\alpha \);
        \item such that \( A_\alpha \) is a group;
        \item a group homomorphism \( A_\alpha \to S_\alpha \);
        \item a group action of \( A_\alpha \) on \( \tau_\alpha \);
        \item for each \( t : \tau_\alpha \), a support for \( t \) under the action of \( A_\alpha \), called its \emph{designated support}.
    \end{itemize}
\end{definition}
\begin{remark}
    The homomorphism \( A_\alpha \to S_\alpha \) is applied implicitly where needed.
\end{remark}
\begin{definition}
    Let \( \alpha : \lambda^\bot \), and suppose we have core tangle data at \( \alpha \).
    \emph{Positioned tangle data at level \( \alpha \)} is an injective \emph{position} function \( \iota_\alpha \colon \tau_\alpha \to \mu \).
\end{definition}
\begin{remark}
    This is separated from core tangle data because, while core tangle data is quite easy to construct at a given level, constructing the positioned tangle data requires the freedom of action theorem.
\end{remark}
\begin{definition}
    Let \( \alpha : \lambda \), and suppose we have core tangle data at \( \alpha \).
    \emph{Almost tangle data at level \( \alpha \)} (rename this!) is
    \begin{itemize}
        \item an injection \( a_\alpha \) from the type of atoms into \( \tau_\alpha \) called the \emph{typed atom map};
        \item an injection \( N_\alpha \) from the type of near-litters to \( \tau_\alpha \) called the \emph{typed near-litter map};
        \item an injection \( p_\alpha \) from \( \tau_\alpha \) to the type of pretangles \( \tau_\alpha^\star \);
        \item where all such maps are equivariant with respect to \( A_\alpha \).
    \end{itemize}
\end{definition}
\begin{definition}
    If we have almost tangle data at \( \beta \) and \( \alpha \) where \( \beta < \alpha \), there is a membership relation between \( \tau_\beta \) and \( \tau_\alpha \) by mapping them to \( \tau_\beta^\star \) and \( \tau_\alpha^\star \), which has such a membership relation.
\end{definition}
\begin{definition}
    \emph{Position data} is an injection \( \iota_a \) from the type of atoms into \( \mu \).
\end{definition}
\begin{remark}
    This is the position of a typed singleton in the position function at any level.
\end{remark}
\begin{definition}
    Let \( \alpha : \lambda \), and suppose we have core tangle data, positioned tangle data, and almost tangle data at \( \alpha \), as well as position data.
    Then, \emph{tangle data at level \( \alpha \)} is
    \begin{itemize}
        \item for each atom \( a \), a proof that \( \iota_\alpha(a_\alpha(a)) = \iota_a(a) \);
        \item for each atom \( a \), a proof that \( \iota_\alpha(N_\alpha(L)) < \iota_a(a) \) where \( a \) is contained in the litter set of \( L \);
        \item for each near-litter \( N \), a proof that \( \iota_\alpha(N_\alpha(N^\circ)) \leq \iota_\alpha(N_\alpha(N)) \);
        \item for each near-litter \( N \) and atom \( a \in N\,\triangle\,N^\circ \), a proof that \( \iota_a(a) < \iota_\alpha(N_\alpha(N)) \);
        \item for each \( t : \tau_\alpha \) that is not a typed singleton or typed near-litter, and each support condition \( (x,A) \) in the designated support of \( t \), a proof that \( \iota_\alpha(a_\alpha(x)) \leq \iota_\alpha(t) \) or \( \iota_\alpha(N_\alpha(x)) \leq \iota_\alpha(t) \) depending on the value of \( x \).
        \item and some other conditions that aren't completely solidified yet (at least in type theory).
    \end{itemize}
    TODO: We probably want to put the typed near litter position function into the position data, so that we can keep track of it independent of \( \alpha \).

    Note on `condition 4' from \texttt{retangled.pdf}: if we have to enforce the \( \iota_\ast(X_\alpha) \geq \iota_\ast(X_0) \) condition, this would probably add quite a lot of complexity, because we don't currently have the ability to take sets \( X_0 \) and turn them into things in \( X_\alpha \).
\end{definition}
\begin{remark}
    This will be constructed for all proper type indices \( \alpha \).
\end{remark}
\begin{definition}
    We have core and positioned tangle data for \( \bot \) as follows.
    \begin{itemize}
        \item \( \tau_\bot \) is the type of atoms;
        \item \( A_\bot \) is the type of near-litter permutations;
        \item the designated support of each atom is \( \qty{(a, \mathsf{nil})} \);
        \item the position function is arbitrary.
    \end{itemize}
\end{definition}
\begin{definition}
    Let \( \alpha : \lambda \).
    \emph{Cumulative (core, positioned, almost) tangle data below level \( \alpha \)} is (core, positioned, almost) tangle data at all proper type indices below level \( \alpha \).
\end{definition}
\begin{ih}
    Suppose we are constructing tangles at level \( \alpha \).
    We assume that we have cumulative tangle data (of all kinds) below level \( \alpha \).
\end{ih}
\begin{remark}
    When accessing the tangle data in proofs, we want to ensure that \( \tau_\bot \) is always known to be the type of atoms, and \( A_\bot \) is always known to be the type of near-litter permutations.
    To enforce this, the accessor functions for tangle data at \( \beta \) first checks if \( \beta = \bot \); if this is true, we return the known tangle data at \( \bot \), and otherwise, we return the instance from the cumulative tangle data assumption.
\end{remark}

\subsection{Codes}

\begin{definition}
    An \emph{\( \alpha \)-code} is a type index \( \beta : \lambda_\alpha \) and a set of \( \beta \)-tangles.
\end{definition}

\subsection{\( f \)-maps}

\begin{lemma}
    Let \( \alpha, \beta \) be types, where \( \alpha \) is well-ordered.
    Let \( D \colon \alpha \to \mathcal P \beta \) assign a \emph{denied set} to each element of \( \alpha \).
    Suppose that for each \( x : \alpha \), \( \#\qty{y \mid y < x} + \#(D (x)) < \#\beta \).
    Then, there is an injective function \( f \colon \alpha \to \beta \) such that \( f(x) \not\in D(x) \) for each \( x : \alpha \).
\end{lemma}
\begin{proof}
    We explicitly construct such a function.
    Let \( x \in \alpha \).
    The set \( \qty{f(y) \mid y < x} \cup D(x) \) has cardinality strictly smaller than \( \#\beta \), so there exists an element of \( \beta \) outside this set that we will assign to \( f(x) \).
\end{proof}
In this section, let \( \beta : \lambda^\bot, \gamma : \lambda \), and suppose we have positioned tangle data at \( \beta \) and positioned and almost tangle data at \( \gamma \), with \( \beta \neq \gamma \).
\begin{definition}
    Let \( i : \mu \) and \( t : \tau_\beta \).
    We say that \( i \) is \emph{\( f \)-denied} by \( t \) if
    \begin{itemize}
        \item there is a near-litter \( N \) to the litter \( \langle i, \beta, \gamma \rangle \) such that \( \iota_\gamma(N_\gamma(N)) \leq \iota_\beta(t) \); or
        \item \( \beta = \bot \) and \( \iota_\gamma(N_\gamma(\langle i, \bot, \gamma \rangle)) \leq \iota_a(t) \).
    \end{itemize}
\end{definition}
\begin{lemma}
    Let \( t : \tau_\beta \).
    Then,
    \[ \#\qty{s \mid \iota_\beta(s) < \iota_\beta(t)} + \#\qty{i \mid i \text{ is \( f \)-denied by } t} < \#\mu \]
\end{lemma}
\begin{definition}
    The function \( f_{\beta,\gamma} \colon \tau_\beta \to \mathsf{litter} \) is defined by \( \langle f, \beta, \gamma \rangle \) where \( f \colon \tau_\beta \to \mu \) is an injective function constructed using the above lemma such that \( f(x) \) is not \( f \)-denied by \( x \) for each \( x \).
\end{definition}
\begin{lemma}
    For \( t : \tau_\beta \) and \( N \) a near-litter to \( f_{\beta,\gamma}(t) \), we have \( \iota_\beta(x) < \iota_\gamma(N_\gamma(N)) \).
    If \( \beta = \bot \), we also have \( \iota_a(t) < \iota_\gamma(N_\gamma(f_{\bot,\gamma}(a))) \).
\end{lemma}

\subsection{\( A \)-maps}

Let \( \alpha : \lambda, \beta : \lambda_\alpha, \gamma : \lambda^\bot_\alpha, \beta \neq \gamma \).
Suppose we have positioned tangle data at \( \gamma \) and positioned and almost tangle data at \( \beta \).
\begin{definition}
    The function \( A_{\gamma,\beta} \colon \mathcal P \tau_\gamma \to \mathcal P \tau_\beta \) is defined by
    \[ A_{\gamma,\beta}(S) = \qty{N_\beta(N) \mid N \in \bigcup_{t \in S} \qty[f_{\gamma,\beta}(t)]} \]
    where \( [L] \) denotes the local cardinal of \( L \).
\end{definition}
\begin{lemma}
    The \( A_{\gamma,\beta} \) for varying \( \gamma \) are injective and have disjoint ranges.
\end{lemma}
\begin{lemma}
    Let \( S : \mathcal P \tau_\gamma \) be a nonempty set of \( \gamma \)-tangles.
    Then, \( \min_{t \in S} \iota_\gamma(t) < \min_{t \in A_{\gamma,\beta}(S)} \iota_\beta(t) \).
\end{lemma}
\begin{definition}
    We define the \emph{extension function} \( E_{\beta,\gamma} \colon \mathcal P \tau_\beta \to \mathcal P \tau_\gamma \) by \( A_{\beta,\gamma} \) if \( \beta \neq \gamma \), and the identity function otherwise.
\end{definition}
\begin{definition}
    Let \( A_\beta \) be the function from \( \alpha \)-codes to \( \alpha \)-codes given by \( A_\beta(\gamma, S) = (\beta, E_{\gamma,\beta}(S)) \).
\end{definition}
\begin{definition}
    If \( c = (\beta, S) \) is an \( \alpha \)-code, we define the \emph{code position} to be \( \iota_c(c) = \min_{t \in S} \iota_\beta(t) \).
\end{definition}
\begin{lemma}
    Let \( c \) be an \( \alpha \)-code.
    Then, \( \iota_c(c) < \iota_c(A_\beta(c)) \).
\end{lemma}
\begin{definition}
    We define the relation \( \leadsto \) on \( \alpha \)-codes by defining \( c \leadsto A_\beta(c) \) when \( c = (\gamma, S)\) and \( \beta \neq \gamma \).
\end{definition}
\begin{lemma}
    If \( d_1, d_2 \leadsto c \), then \( d_1 = d_2 \).
    If \( c \leadsto d_1, d_2 \), then \( d_1 = d_2 \).
    The relation \( \leadsto \) is well-founded.
\end{lemma}

\subsection{Equivalence of codes}

\begin{definition}
    We define inductively that an \( \alpha \)-code \( c \) is
    \begin{itemize}
        \item \emph{even} if for all \( d \leadsto c \), \( d \) is odd;
        \item \emph{odd} if there exists \( d \leadsto c \) such that \( d \) is even.
    \end{itemize}
\end{definition}
\begin{lemma}
    The map \( A_\beta \) swaps the parity of a code \( (\gamma, S) \) if \( \beta \neq \gamma \).
    Empty codes are even if and only if their extension is \( \bot \).
    Singleton codes are even.
\end{lemma}
\begin{definition}
    We define the relation of \emph{equivalence} between \( \alpha \)-codes inductively by
    \begin{itemize}
        \item \( c \equiv c \);
        \item \( A_\beta(c) \equiv c \) where \( c = (\gamma, S) \) and \( \beta \neq \gamma \);
        \item \( c \equiv A_\beta(c) \) where \( c = (\gamma, S) \) and \( \beta \neq \gamma \); or
        \item \( A_\beta(c) \equiv A_\gamma(c) \) where \( c = (\delta, S) \) and \( \beta \neq \delta, \gamma \neq \delta \).
    \end{itemize}
\end{definition}
\begin{lemma}
    This is an equivalence relation.
    All empty codes are equivalent.
    If \( (\gamma, S) \equiv (\gamma, T) \) then \( S = T \).
    There exists exactly one even code in any equivalence class.
\end{lemma}

\subsection{Allowable permutations}

% assumptions?

\begin{definition}
    An \emph{\( \alpha \)-semiallowable permutation} is a dependent product such that for each \( \beta : \lambda^\bot_\alpha \), we have a \( \beta \)-allowable permutation.
    The type of \( \alpha \)-semiallowable permutations is written \( Q_\alpha \) (we probably want better naming than this).
\end{definition}
\begin{lemma}
    There is a multiplicative action of \( Q_\alpha \) on \( \tau_\beta \) for all \( \beta : \lambda^\bot_\alpha \).
    There is a natural homomorphism \( d_{\alpha,\beta} \colon Q_\alpha \to A_\beta \) for each \( \beta : \lambda^\bot_\alpha \), and we write \( \pi_\beta = d_{\alpha,\beta}(\pi) \).
    There is a homomorphism \( Q_\alpha \to S_\alpha \), giving it more multiplicative actions.
    Semiallowable permutations act on \( \alpha \)-codes by \( \pi(\gamma, S) = (\gamma, \pi(S)) \).
\end{lemma}
\begin{definition}
    An \emph{\( \alpha \)-allowable permutation} is an \( \alpha \)-semiallowable permutation whose action on codes preserves code equivalence, so \( c \equiv d \iff \pi(c) \equiv \pi(d) \).
    The type is written \( P_\alpha \).
\end{definition}
\begin{lemma}
    Allowable permutations act on everything that semiallowable permutations do.
\end{lemma}
\begin{theorem}[coherence of allowable permutations]
    Let \( t : \tau_\beta \) and \( \beta \neq \gamma \), and let \( \pi : P_\alpha \).
    Then,
    \[ (\pi_\gamma)_\bot(f_{\beta,\gamma}(t)) = f_{\beta,\gamma}(\pi_\beta(t)) \]
    Note that \( (\pi_\gamma)_\bot \) first computes the \( \beta \)-allowable permutation \( \pi_\gamma \) using the \( d_{\alpha,\gamma} \) map, then computes its \( \bot \)-derivative by interpreting \( \pi_\gamma \) as a \( \gamma \)-structural permutation; the latter coercion exists by the core tangle data inductive hypothesis.
    Let \( S : \mathcal P \tau_\beta \).
    Then,
    \[ \pi_\gamma(A_{\beta,\gamma}(S)) = A_{\beta,\gamma}(\pi_\beta(S)) \]
    Let \( c = (\gamma, S) \) be a code with \( \beta \neq \gamma \).
    Then,
    \[ \pi(A_\gamma(c)) = A_\gamma(\pi(c)) \]
    If \( c \) and \( d \) are codes, then \( c \leadsto d \iff \pi(c) \leadsto \pi(d) \).
    \( c \) is even if and only if \( \pi(c) \) is even.
\end{theorem}

\subsection{Tangles}

\begin{definition}
    An \emph{extension collection} is a dependent product such that for each \( \beta : \lambda_\alpha \). we have a set of \( \beta \)-tangles.
    We write \( e_\beta \) for this set of \( \beta \)-tangles, where \( e \) is the extension collection.
\end{definition}
\begin{definition}
    A \emph{preference} of an extension collection \( e \) is
    \begin{itemize}
        \item a set of atoms \( X : \mathcal P \tau_\bot \) such that for all \( \gamma : \lambda_\alpha \), we have \( A_{\bot,\gamma}(X) = e_\gamma \); or
        \item a proper type index \( \beta : \lambda_\alpha \) such that \( (\beta, e_\beta) \) is an even code, and for all \( \gamma : \lambda_\alpha \) where \( \beta \neq \gamma \), \( A_{\beta,\gamma}(e_\beta) = e_\gamma \).
    \end{itemize}
\end{definition}
\begin{definition}
    A \emph{semitangle} is an extension collection with a preference.
    If \( s = (e, p) \) is a semitangle, we write \( s_\gamma \) to abbreviate \( e_\gamma \), and \( s_{\mathsf{pref}} \) for \( p \).
    % TODO: \iota_a and \iota_c using mathsf?
\end{definition}
\begin{lemma}
    There is a membership relation between \( \gamma \)-tangles and \( \alpha \)-semitangles, for all \( \gamma : \lambda_\alpha \), by considering its extension collection.
    Each semitangle has an even code representing it, and every even code gives a semitangle.
\end{lemma}
\begin{theorem}
    Semitangles are extensional at \emph{each} \( \gamma : \lambda_\alpha \).
    More precisely, if \( s_1, s_2 \) are semitangles and \( \gamma : \lambda_\alpha \), then \( (s_1)_\gamma = (s_2)_\gamma \) implies \( s_1 = s_2 \).
    In addition, if \( \alpha = 0 \), semitangles are extensional at level \( \bot \).
\end{theorem}
\begin{lemma}
    There is a multiplicative action of allowable permutations on semitangles.
    Allowable permutations commute with taking extensions of semitangles, and with the membership relation.
\end{lemma}
\begin{definition}
    An \emph{\( \alpha \)-new tangle} is a semitangle that is supported under the action of \( \alpha \)-allowable permutations.
\end{definition}
\begin{lemma}
    There are new tangles representing typed near-litters, typed singletons, and typed small sets of supported \( \beta \)-tangles for \( \beta : \lambda_\alpha^\bot \).
\end{lemma}
\begin{lemma}
    Allowable permutations act on new tangles.
\end{lemma}

\section{Freedom of action}

\subsection{Strong supports}

\begin{definition}
    We define the relation \( \prec \) on \( \alpha \)-support conditions by
    \begin{itemize}
        \item \( (L, A) \prec (a, A) \) where \( a \) is an element of the litter set of \( L \);
        \item \( (N^\circ, A) \prec (N, A) \) where \( N \) is a near-litter that is not a litter;
        \item \( (a, A) \prec (N, A) \) where \( a \in N\,\triangle\,N^\circ \) and \( N \) is a near-litter;
        \item
            if \( A \) is a path from \( \alpha \) to \( \beta \),
            \( t : \tau_\gamma \) is a \( \gamma \)-tangle where \( \gamma : \lambda^\bot \) and \( \gamma < \beta \),
            \( (x, B) \) is an element of the designated \( \gamma \)-support of \( t \),
            and \( \delta < \beta \) is a proper type index not equal to \( \gamma \),
            then
            \[ (x, A \gg (\beta \longrightarrow \gamma) \gg B) \prec (f_{\gamma,\delta}(t), A \gg (\beta \longrightarrow \delta) \gg (\delta \longrightarrow \bot)) \]
        \item if \( A \) is a path from \( \alpha \) to \( \beta \), \( \gamma < \beta \) is a proper type index, and \( a : \tau_\bot \) is an atom, then
        \[ (a, A \gg (\beta \longrightarrow \bot)) \prec (f_{\bot,\delta}(a), A \gg (\beta \longrightarrow \delta) \gg (\delta \longrightarrow \bot)) \]
    \end{itemize}
\end{definition}
\begin{definition}
    We define a well-ordering on support conditions by \( (x, A) < (y, B) \) where \( \iota(x) < \iota(y) \) under the appropriate typed singleton or typed near-litter map, but if \( \iota(x) = \iota(y) \), we say \( (x, A) < (y, B) \) if \( A < B \) for a fixed well-ordering of extended type indices.
\end{definition}
\begin{lemma}
    \( \prec \) is well-founded, because \( (x, A) \prec (y, B) \) implies \( (x, A) < (y, B) \).
\end{lemma}
\begin{lemma}
    Suppose \( x : \tau_\alpha \) is supported.
    Then \( x \) has a support \( S \) such that if \( (N_1, A), (N_2, A) \in S \) are near-litter support conditions, we have \( N_1 \cap N_2 = \varnothing \).
    We call such supports \emph{disjoint supports}.
\end{lemma}
\begin{definition}
    A support \( S \) is \emph{strong} if
    \begin{itemize}
        \item it is a disjoint support; and
        \item \( c \prec d \) and \( d \in S \) implies \( c \in S \).
    \end{itemize}
\end{definition}
\begin{lemma}
    If \( (N, A) \in S \) is a near-litter support condition in a strong support, then \( N \) is the litter set of some litter.
    % TODO: Is it convenient to have a different type where the fact that \( N \) is a litter is known?
    % I don't think it is any more, but I'll keep the note as a comment anyway.
\end{lemma}
\begin{lemma}
    Any support can be converted into a strong support.
    % in \( \omega \) stages of adding missing items, adding a small collection of new items at each stage.
\end{lemma}

\subsection{Approximations}

\begin{definition}
    Let \( \alpha \) be a type.
    A \emph{local permutation} of \( \alpha \) is
    \begin{itemize}
        \item a pair of functions \( f, g \colon \alpha \to \alpha \);
        \item a \emph{domain} set of elements \( A : \mathcal P \alpha \);
        \item a proof that \( f(A) \subseteq A \) and \( g(A) \subseteq A \);
        \item a proof that \( g(f(a)) = a = f(g(a)) \) for all \( a \in A \).
    \end{itemize}
    If \( \pi^0 \) is a local permutation, then we write \( \dom \pi^0 \) for \( A \), \( \pi^0(a) \) for \( f(a) \), and \( (\pi^0)^{-1}(a) \) for \( g(a) \).
    % similar to mathlib3's logic.equiv.local_equiv
\end{definition}
\begin{definition}
    A \emph{sublitter} is a litter \( L \) together with a subset \( S \) of the litter set of \( L \), such that \( L \setminus S \) is small (interpreting \( L \) as its litter set).
\end{definition}
\begin{remark}
    All sublitters are near-litters, and we interpret them as such.
    For instance, we use \( S^\circ \) to denote the litter associated to a sublitter.
\end{remark}
\begin{definition}
    A \emph{near-litter approximation} is
    \begin{itemize}
        \item a local permutation \( \pi^0_a \) of atoms;
        \item a local permutation \( \pi^0_\ell \) of litters;
        \item such that \( \dom \pi^0_a \cap L \) is small for each litter \( L \).
    \end{itemize}
\end{definition}
\begin{remark}
    This definition is independent of our parameters at this level of the construction; it could have even been defined before core tangle data.
    The last condition ensures that if \( S_1, S_2 \) have \( S_1^\circ = S_2^\circ \), then at most one of \( S_1, S_2 \) can live in \( \dom \pi^0_s \).
\end{remark}
\begin{lemma}
    Near-litter approximations \( \pi^0 \) act on sublitters \( S \) by defining
    \[ \pi^0_s(S) = \pi^0_\ell(S^\circ) \setminus \dom \pi^0_a \]
    The image is always a sublitter because of the constraint that \( \dom \pi^0_a \cap L \) is small.
    This is not a group action, not only because near-litter approximations do not form a group, but also because \( \pi^0_s \) is not injective.
    However, this gives a local permutation of sublitters \( \pi^0_s \) defined on the domain
    \[ \qty{S \mid S^\circ \in \dom \pi^0_\ell;\; S = S^\circ \setminus \dom \pi^0_a} \]
    such that if \( S \in \dom \pi^0_s \), then \( \pi^0_s(S)^\circ = \pi^0_\ell(S^\circ) \).
\end{lemma}
\begin{definition}
    A near-litter permutation \( \pi : S_\bot \) has \emph{exception} \( a : \tau_\bot \) if \( \pi_a(a) \not\in \pi_\ell(L) \) or \( \pi^{-1}_a(a) \not\in \pi^{-1}_\ell(L) \), where \( a \) lies in the litter set of \( L \).
\end{definition}
\begin{definition}
    A near-litter approximation \( \pi^0 \) \emph{approximates} a near-litter permutation \( \pi : S_\bot \) if
    \begin{itemize}
        \item \( a \in \dom \pi^0_a \) implies \( \pi^0_a(a) = \pi_a(a) \);
        \item \( L \in \dom \pi^0_\ell \) implies \( \pi^0_\ell(L) = \pi_\ell(L) \); and
        \item \( S \in \dom \pi^0_s \) implies \( \pi^0_s(S) = \pi_a(S) \).
    \end{itemize}
    In addition, we say that \( \pi^0 \) \emph{exactly approximates} \( \pi \) if
    \begin{itemize}
        \item \( \pi^0 \) approximates \( \pi \); and
        \item if \( a \) is an exception of \( \pi \), then \( a \in \dom \pi^0_a \).
    \end{itemize}
\end{definition}
\begin{definition}
    A \emph{\( \beta \)-approximation} is a product that assigns a near-litter approximation to each \( \beta \)-extended index.
    We write \( \pi^0_A \) for the near-litter approximation given by the \( \beta \)-extended index \( A \).
    A \( \beta \)-approximation \( \pi^0 \) \emph{(exactly) approximates} a \( \beta \)-structural permutation \( \pi : S_\beta \) if \( \pi^0_A \) (exactly) approximates \( \pi_A \) for all \( A \).
\end{definition}
\begin{definition}
    A litter \( L \) is \emph{\( A \)-inflexible} if \( A = B \gg (\beta \longrightarrow \delta) \gg (\delta \longrightarrow \bot) \), and there exists \( \gamma : \lambda^\bot \) with \( \gamma < \beta \) and \( \gamma \neq \delta \), and we have \( t : \tau_\gamma \) such that \( L = f_{\gamma,\delta}(t) \).
    A litter is \( A \)-flexible if it is not \( A \)-inflexible.
\end{definition}
\begin{definition}
    An \emph{\( A \)-free near-litter approximation} is a near-litter approximation \( \pi^0 \) such that if \( L \in \dom \pi^0_\ell \), \( L \) is \( A \)-flexible.
    A \emph{\( \beta \)-free approximation} is a \( \beta \)-approximation \( \pi^0 \) where \( \pi^0_A \) is \( A \)-free for each \( A \).
\end{definition}
\begin{definition}
    If \( \pi^0, \rho^0 \) are near-litter approximations, then we say \( \pi^0 \) \emph{extends} \( \rho^0 \) if the domains of \( \rho^0 \) are contained inside the domains of \( \pi^0 \), and the functions \( \pi^0_a, \pi^0_\ell, \pi^0_s \) agree with \( \rho^0_a, \rho^0_\ell, \rho^0_s \) on the domain of \( \rho^0 \).
    If \( \pi^0, \rho^0 \) are \( \beta \)-approximations, \( \pi^0 \) extends \( \rho^0 \) if \( \pi^0_A \) extends \( \rho^0_A \) for all \( A \).
\end{definition}

\subsection{Freedom of action}

\begin{definition}
    Let \( S_1, S_2 \) be sublitters.
    We define \( \pi_{S_1,S_2} \) to be an arbitrary bijection between the two sublitters, which exists as they both have cardinality \( \#\kappa \).
\end{definition}
\begin{definition}
    Let \( \pi^0 \) be a free near-litter approximation.
    Its \emph{\( A \)-flexible litter completion} is the free near-litter approximation \( \rho^0 \) given by
    \begin{itemize}
        \item \( \rho^0_a = \pi^0_a \);
        \item \( \rho^0_\ell \) is the local approximation of litters extending \( \pi^0_\ell \) that acts as the identity on all \( A \)-flexible litters not in \( \dom \pi^0_\ell \);
        \item \( \rho^0_s \) is the extension of \( \pi^0_s \) given by defining \( \rho^0_s(S) = S \) where \( S = L \setminus \dom \pi^0_a \) for each \( A \)-flexible litter \( L \) not in \( \dom \pi^0_\ell \).
    \end{itemize}
\end{definition}
\begin{ih}
    Let \( \pi^0 \) be a \( \beta \)-approximation, and let \( c \) be a \( \beta \)-support condition.
    A \emph{\( c \)-hypothesis} \( H \) is
    \begin{itemize}
        \item a dependent product \( H_a \) such that for each atom \( a \) and \( \beta \)-extended index \( A \), if \( (a, A) \prec c \), we have an atom;
        \item a dependent product \( H_n \) such that for each near-litter \( N \) and \( \beta \)-extended index \( A \), if \( (N, A) \prec c \), we have a near-litter.
    \end{itemize}
\end{ih}
\begin{definition}
    Let \( \pi^0 \) be a \( \beta \)-approximation, let \( a \) be an atom, \( A \) be a \( \beta \)-extended index, and let \( H \) be an \( (a, A) \)-hypothesis.
    Then, the \emph{atom completion} of \( \pi^0 \) at \( a \) is defined by
    \[ \begin{cases}
        (\pi^0_A)_a(a) & \text{if } a \in \dom (\pi^0_A)_a \\
        \pi_{L \setminus \dom (\pi^0_A)_a, H_n(L, A)^\circ \setminus \dom (\pi^0_A)_a}(a) & \text{otherwise}
    \end{cases} \]
    TODO: Check that \( H_n(L, A)^\circ \), not \( H_n(L, A) \), is the correct interpretation of the paper.
\end{definition}
\begin{definition}
    Let \( \pi^0_a \) be a local permutation of atoms with small domain.
    The \emph{\( A \)-derived approximation} of \( \pi^0_a \) with respect to \( \pi^0 \) is the near-litter approximation given by \( \pi^0_a \) and \( \pi^0_\ell \), where \( \pi^0_\ell \) is the local permutation of litters of the \( A \)-flexible litter completion of \( \pi^0 \).
\end{definition}
\begin{definition}
    Let \( \mathcal A \colon \mathcal P (\tau_\bot \times \tau_\bot) \) be a small set of pairs of atoms, where atoms may appear at most once as the first entry and the second entry (set-theoretically, \( \mathcal A \) is an injective partial function from the type of atoms to itself).
    Let \( L \) be a litter that none of the atoms in \( \mathcal A \) are contained within.
    We define the atom permutation \emph{generated by} \( \mathcal A \) using \( L \) to be a local permutation \( \pi^0_a \) of atoms such that
    \begin{itemize}
        \item \( \dom \pi^0_a \subset \pi_1(\mathcal A) \cup \pi_2(\mathcal A) \cup L \);
        \item \( \#(\dom \pi^0_a) < \#\kappa \);
        \item \( (a, b) \in \mathcal A \implies \pi^0_a(a) = b \).
    \end{itemize}
\end{definition}
\begin{definition}
    Let \( T \) be a strong \( \gamma \)-support for \( t : \tau_\gamma \), and let \( H \) be a \( (B \gg (\beta \longrightarrow \delta) \gg (\delta \longrightarrow \bot), f_{\gamma,\delta}(t)) \)-hypothesis.
    For each \( \gamma \)-extended index \( A \),
    \begin{itemize}
        \item Let \( \mathcal A = \bigcup_{(a, A) \in T} \qty{(a, H_a(a, A))} \).
        \item Let \( \mathcal L \) be the set of \( A \)-flexible litters \( L \) such that \( (L, A) \in T \).
        \item Then, define
        \[ \mathcal A_1 = \bigcup_{L \in \mathcal L} H_n(L, A) \setminus H_n(L, A)^\circ;\quad \mathcal A_2 = \bigcup_{L \in \mathcal L} H_n(L, A)^\circ \setminus H_n(L, A) \]
        Then, \( \mathcal A_2 \setminus \mathcal A_1 \) is the set of atoms contained in litters near the image of \( T \), but not contained in the image of \( T \) itself.
        \item Let \( L_1, L_2 \) be litters disjoint from \( \mathcal A, \mathcal L \), and the \( H_n(L, A) \).
        \item Let \( \mathcal A^+ \) be the union of \( \mathcal A \) with elements of the form \( (a, b) \) where \( a \in L_1 \) and \( b \in \mathcal A_2 \setminus \mathcal A_1 \).
        \item Let \( \pi^0_a \) be the atom permutation generated by \( \mathcal A^+ \) using \( L_2 \), and let \( \pi^0 \) be its \( A \)-derived approximation.
    \end{itemize}
    The resulting \( \pi^0 \) are combined to form a \( \gamma \)-approximation called the \emph{derived approximation} of \( T \).
\end{definition}
\begin{remark}
    The construction shown above is quite arduous, but it does constructively prove the existence of the required \( \gamma \)-approximation.
    Is there a better method?
\end{remark}
\begin{definition}
    We say \emph{freedom of action holds at level \( \gamma \)} if every \( \gamma \)-free approximation exactly approximates some \( \gamma \)-allowable permutation.
\end{definition}
\begin{definition}
    Let \( L \) be an \( A \)-inflexible litter, so \( A = B \gg (\beta \longrightarrow \delta) \gg (\delta \longrightarrow \bot) \), and \( L = f_{\gamma,\delta}(t) \) for some \( \gamma : \lambda^\bot \) with \( \gamma < \beta \) and \( \gamma \neq \delta \).
    Let \( H \) be an \( (L, A) \)-hypothesis.
    Suppose freedom of action holds at level \( \gamma \).
    Then, the \emph{\( A \)-inflexible litter completion} of \( \pi^0 \) at \( L \) is defined to be
    \[ \begin{cases}
        f_{\bot,\delta}(H_a(t, B \gg (\beta \longrightarrow \bot))) & \text{if } \gamma = \bot \\
        f_{\gamma,\delta}(\pi'_{B \gg (\beta \longrightarrow \gamma)}(t)) & \text{otherwise}
    \end{cases} \]
    where \( \pi' \) is a \( \gamma \)-allowable permutation given by applying the freedom of action theorem to the \( \gamma \)-allowable approximation derived from a strong \( \gamma \)-support of \( t \).
\end{definition}
\begin{remark}
    To use the freedom of action theorem above, we need to assume that the derived \( \gamma \)-allowable approximation is free.
    This can't be proven inside the recursion, but fortunately we don't actually need the result here.
    We can define \( \pi' \) to be the result of applying the freedom of action theorem if the hypotheses are satisfied, or the identity \( \gamma \)-allowable permutation otherwise.
    The latter case will never actually occur, but it allows us to defer the proof of this fact until later.
\end{remark}
\begin{definition}
    Let \( L \) be a litter.
    The \emph{\( A \)-litter completion} of \( \pi^0 \) at \( L \) is
    \begin{itemize}
        \item the image of \( L \) under the \( A \)-flexible litter completion if \( L \) is \( A \)-flexible;
        \item the image of \( L \) under the \( A \)-inflexible litter completion if \( L \) is \( A \)-inflexible.
    \end{itemize}
\end{definition}
\begin{definition}
    Let \( S \) be a sublitter.
    Let \( S_1 = S^\circ \setminus \dom \pi^0_a \) be the largest sublitter of \( S^\circ \) containing no atom in the domain of \( \pi^0_a \).
    Let \( S_2 = L \setminus \dom \pi^0_a \) be the largest sublitter of the \( A \)-litter completion of \( \pi^0 \) at \( S^\circ \) containing no atom in the domain of \( \pi^0_a \).
    Then, the \emph{\( A \)-sublitter completion} of \( \pi^0 \) at \( S \) is
    \[ (S_2 \cup \pi^0_A(S \setminus S_1)) \setminus \pi_{S_1,S_2}(S_1 \setminus S) \]
\end{definition}
\begin{definition}
    Let \( N \) be a near-litter, and \( H \) be an \( (N, A) \)-hypothesis.
    The \emph{\( A \)-near-litter completion} of \( \pi^0 \) at \( N \) is the union of the \( A \)-sublitter completion of \( N \cap N^\circ \), together with the images of each atom in \( N \setminus N^\circ \) obtained from the hypothesis.
\end{definition}
\begin{definition}
    Let \( \pi^0 \) be a \( \beta \)-approximation, and suppose freedom of action holds at all \( \gamma < \beta \).
    The \emph{completed action} of \( \pi^0 \) is
    \begin{itemize}
        \item a function on an atom \( a \) and a \( \beta \)-extended index \( A \), which returns the atom completion of \( \pi^0 \) on \( a \);
        \item a function on a near-litter \( N \) and a \( \beta \)-extended index \( A \), which returns the \( A \)-near-litter completion of \( \pi^0 \) at \( N \).
    \end{itemize}
\end{definition}
\begin{remark}
    This definition is constructed by well-founded recursion on the type of support conditions.
\end{remark}
\begin{lemma}
    The completed action of a free \( \beta \)-approximation \( \pi^0 \) is the image of an allowable permutation.
\end{lemma}
\begin{remark}
    This requires an inductive hypothesis in the main recursion which has not yet been defined.
\end{remark}
\begin{corollary}
    \( \pi^0 \) exactly approximates some allowable permutation.
\end{corollary}
\begin{theorem}
    Freedom of action holds at every level \( \beta < \alpha \).
\end{theorem}

\end{document}
